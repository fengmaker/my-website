这份代码集合涵盖了**子集型回溯**及其变体（组合型、二叉选择型）。我们可以将其统一归纳为“**在每个位置面临选择**”的问题。

以下是为你总结的**子集型回溯算法笔记**，基于你提供的四道题目进行提炼。

---

# 算法笔记：子集型回溯 (Subset-Type Backtracking)

### 1. 核心思想：选或不选 (Pick or Not Pick)

子集型回溯的本质是构造一棵 二叉树（或多叉树）。

对于输入数组中的每一个元素 nums[i]，我们只有两种（或有限种）选择：

1. **不选**（跳过）：直接进入下一层递归。
    
2. **选**（加入路径）：将该元素加入 `path`，进入下一层递归，回溯时撤销。
    

**时间复杂度**：$O(2^N)$，因为每个元素都有 2 种状态。

---

### 2. 通用模版

#### 模版 A：需要记录具体路径 (如 `Subsets`)

这是最标准的子集型回溯，对应你的第 4 段代码。

Python

```
def subsets(nums):
    ans = []
    path = []
    n = len(nums)
    
    def dfs(i):
        # Base Case: 遍历完所有元素，记录当前路径
        if i == n:
            ans.append(path.copy()) # 注意要 copy
            return
        
        # 分支 1: 不选当前元素 (Skip)
        dfs(i + 1)
        
        # 分支 2: 选择当前元素 (Pick)
        path.append(nums[i])
        dfs(i + 1)
        path.pop() # 回溯：恢复现场
        
    dfs(0)
    return ans
```

#### 模版 B：只需要计算统计值 (如 `subsetXORSum`)

如果题目不需要返回所有子集的具体内容，而是求和、求异或等统计值，可以将 `path` 省略，直接通过**函数参数**传递状态。对应你的第 3 段代码。

Python

```
def subsetXORSum(nums):
    ans = 0
    n = len(nums)
    
    # s 代表当前路径累积的异或和
    def dfs(i, s):
        if i == n:
            nonlocal ans
            ans += s
            return
        
        # 分支 1: 不选
        dfs(i + 1, s)
        
        # 分支 2: 选 (直接在参数中计算，无需 push/pop)
        dfs(i + 1, s ^ nums[i])
        
    dfs(0, 0)
    return ans
```

---

### 3. 变体模式分析

根据你提供的代码，子集型回溯有以下几种常见的“变身”：

#### 变体 1：固定长度的“多叉”选择 (电话号码组合)

- **区别**：这不是典型的“选或不选”，而是“**必选一个，但有多个选项**”。
    
- **结构**：二叉树变成了多叉树。
    
- **代码特征**：内部使用 `for` 循环枚举当前位置的所有可能字符。
    
    Python
    
    ```
    # 对应 letterCombinations
    for c in MAP[digit]: 
        path.append(c)
        dfs(i + 1)
        path.pop()
    ```
    

#### 变体 2：二元状态变换 (大小写全排列)

- **区别**：每个位置必须保留一个字符，但字符的状态有两种（大写或小写）。
    
- **结构**：依然是二叉树。
    
- **代码特征**：
    
    - 如果是数字：只有 1 条分支（直接 `dfs(i+1)`）。
        
    - 如果是字母：有 2 条分支（原型 `dfs` vs 变换型 `dfs`）。
        
    - _注：你的代码中使用了预分配 `path` 数组并覆盖的方法，这比 `append/pop` 效率更高，适合已知结果长度固定的情况。_
        

---

### 4. 易错点与技巧

1. **路径的复制**：
    
    - 在 Python 中，`ans.append(path)` 存的是引用。
        
    - **必须写成** `ans.append(path.copy())` 或 `ans.append(path[:])`，否则最终 `ans` 里全是空列表。
        
    - _例外_：如果是字符串拼接（如 `"".join(path)`），因为字符串是不可变的，所以不需要 copy。
        
2. **恢复现场 (Backtracking)**：
    
    - 使用了全局/外部 `path` 变量时，**进递归前 `append`，出递归后必须 `pop`**。
        
    - 如果在递归参数里直接计算（如 `dfs(i+1, s ^ nums[i])`），则**不需要**手动回溯，因为参数是按值传递的（对于数字而言）或并在下一层栈帧中，不影响当前层。
        
3. **剪枝 (Pruning)**：
    
    - 虽然你的示例中没有涉及，但在子集问题中，如果要求“子集和等于 K”，可以在 `dfs` 开头加入 `if current_sum > target: return` 进行剪枝。
        

### 5. 总结口诀

> 子集回溯找所有，
> 
> 选或不选分两头。
> 
> 参数携带状态值，
> 
> 路径记录记 copy。
> 
> 如果选项有多样，
> 
> For 循环里解离愁。

### 接下来做什么？

你已经掌握了最基础的“选或不选”模型。如果你想进阶，可以尝试解决以下两种情况：

1. **数组中有重复元素**，要求生成的子集不能重复（如 `90. 子集 II`）。
    
    - _提示：需要先排序，然后用 `if i > 0 and nums[i] == nums[i-1]` 剪枝。_
        
2. **限制子集的大小**（如 `77. 组合`）。
    
    - _提示：剪枝，当剩下的元素不足以凑齐 k 个时直接 return。_


这是基于你提供的五道题目代码（涵盖了从基础到进阶的各种场景）总结的**子集型回溯算法高阶笔记**。这些题目展示了子集型回溯不仅仅是简单的“选或不选”，还涉及到位运算优化、数学剪枝和状态压缩等技巧。

---

# 算法笔记：子集型回溯进阶 (Subset-Type Backtracking Advanced)

## 1. 核心模型回顾

子集型回溯的本质是遍历一颗 **二叉树**（或多叉树）。对于数组中的每个元素，我们面临决策：

1. **不选 (Skip)**：直接处理下一个。
    
2. **选 (Pick)**：更新当前状态，处理下一个。
    
    - _变体_：**选 A 还是选 B**（如划分为两个等积子集）。
        

---

## 2. 关键优化与剪枝技巧 (Pruning & Tricks)

这是从你的代码中提炼出的最核心部分，能显著降低复杂度。

### A. 强力剪枝：提前达成目标 (Early Exit via Math)

来源：2044. 统计按位或能得到最大值的子集数目

场景：当我们寻找“最大值”或“特定和”时，如果当前状态已经达到理论最大值，剩下的元素无论怎么选都满足条件。

技巧：直接利用数学公式计算剩余的组合数，停止递归。

Python

```
# 核心代码片段
if current_or == total_or:
    # 剩下的 (n - i) 个元素，每个都有“选/不选”两种情况
    # 所以直接加上 2^(n-i)
    ans += 1 << (n - i) 
    return 
```

### B. 可行性剪枝：冲突检测 (Conflict Pruning)

来源：1239. 串联字符串的最大长度

场景：并非任何时候都能“选”。如果当前元素与已选集合冲突（如字符重复），则该分支不可行，必须剪掉。

技巧：在进入“选”的分支前，先检查合法性。

Python

```
# 核心代码片段
# 只有当 mask 和 masks[i] 没有交集（无重复字符）时，才能选
if (mask & masks[i]) == 0:
    dfs(i + 1, mask | masks[i]) # 选
dfs(i + 1, mask)                # 不选（总是可行）
```

### C. 预处理与状态压缩 (Preprocessing & Bitmask)

来源：2397. 被列覆盖的最多行数 和 1239. 串联字符串的最大长度

场景：频繁判断集合之间的关系（如包含、交集、并集）。

技巧：将由 0/1 组成的数组或字符串，预处理为一个 整数 (Bitmask)。

- **集合合并**：`a | b`
    
- **集合求交**：`a & b`
    
- **判断包含**：`(a & b) == b` (a 包含 b)
    
- **计算元素个数**：`mask.bit_count()`
    

Python

```
# 预处理示例 (最大行数)
# 将每一行的 01 列表压缩成一个整数
mask = [sum(x << j for j, x in enumerate(row)) for row in matrix]
```

---

## 3. 常见模版分类

根据题目需求，递归函数的写法略有不同。

### 模版一：参数携带状态 (推荐)

适用：求和、求异或、求积、求并集等不需要记录具体路径的问题。

特点：状态（如 subset, current_or, mask）通过函数参数传递，回溯时无需手动 revert。

Python

```
# 示例：串联字符串、按位或
def dfs(i, current_state):
    if i == n:
        update_ans(current_state)
        return
    
    # 分支 1：选（如果合法）
    if is_valid(current_state, nums[i]):
        dfs(i + 1, update(current_state, nums[i]))
        
    # 分支 2：不选
    dfs(i + 1, current_state)
```

### 模版二：划分型 (Partitioning)

来源：checkEqualPartitions (等积子集)

适用：将数组划分为两个或多个集合。

特点：不是“选或丢弃”，而是“给 A 还是给 B”。

Python

```
# 示例：划分方案
def dfs(i, group_a_val, group_b_val):
    if i == n:
        return check(group_a_val, group_b_val)
    
    # 必须二选一
    return dfs(i + 1, group_a_val * nums[i], group_b_val) or \
           dfs(i + 1, group_a_val, group_b_val * nums[i])
```

### 模版三：路径构建型 (Path Building)

来源：784. 字母大小写全排列

适用：需要返回具体的所有组合内容。

技巧：

1. **预分配内存**：如果知道结果长度（如全排列），用 `path = [""] * n` 配合索引修改，比 `append/pop` 更快。
    
2. **原地修改**：对于字符串变换，直接修改 `path[i]`。
    

---

## 4. 复杂度分析与决策表

在做题时，根据 $N$ 的大小判断是否可用子集回溯：

|**数据规模 (N)**|**复杂度 O(2N)**|**适用情况**|**备注**|
|---|---|---|---|
|$N \le 20$|$\approx 10^6$|**完美适用**|绝大多数子集回溯题目的范围。|
|$N \approx 30$|$\approx 10^9$|**超时**|需要 **折半搜索 (Meet-in-the-middle)** 或 **剪枝**。|
|$N \le 1000$|-|**不可用**|通常是 DP、贪心或滑动窗口。|

## 5. 易错点总结

1. **位运算优先级**：
    
    - `mask & masks[i] == 0` 会被解析为 `mask & (masks[i] == 0)`。
        
    - **必须加括号**：`(mask & masks[i]) == 0`。
        
2. **引用拷贝**：
    
    - 如果记录的是列表 `path`，添加到答案时必须用 `path[:]` 或 `list(path)`。
        
    - 字符串是不可变的，可以直接添加。
        
3. **Base Case 位置**：
    
    - 有些剪枝（如 `countMaxOrSubsets` 的优化）是放在 base case **之前** 的。
        
    - 标准的检查（如 `maximumRows` 的 `bit_count`）通常放在 base case **里面**。
        

---

### 下一步建议

你已经掌握了各种子集型回溯的写法。为了进一步提升，建议：

1. **练习“折半搜索”**（如 `1755. 最接近目标值的子序列和`），这是处理 $N=40$ 左右子集问题的进阶技巧。
    
2. **练习“位运算 DP”**（状压 DP），很多 $N \le 20$ 的题除了回溯，也是状压 DP 的好题。