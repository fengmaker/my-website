这是一份关于**“划分型回溯（Partitioning Backtracking）”**算法的深度总结笔记。

这几道题（131, 93, 2698, 1593, 1849, 140）虽然题目背景各异，但本质上都是**在字符串（或数字序列）的间隙中切几刀，使得切出来的每一段都满足特定条件**。

---

### 一、 核心思维：如何思考“划分”问题

这类问题的本质是 **组合问题** 的变种。

- **组合问题**：是从集合中选取元素。
    
- **划分问题**：是在字符串的 `n-1` 个间隙中选取切割点。
    

#### 思考三部曲：

1. **切割点（Cut）**：我当前站在索引 `startIndex`，我要在哪里切一刀？是切在 `startIndex+1` 还是 `startIndex+2`...？
    
2. **合法性（Valid）**：切出来的这一段（`s[startIndex : i+1]`）符合要求吗？（是回文？是IP段？在字典里？）
    
3. **终点（Base Case）**：切到了字符串末尾，说明找到了一种合法的划分方案，收集结果。
    

---

### 二、 万能通用模版

划分型回溯的代码结构非常统一。掌握以下模版，可以秒杀上述大部分题目。

Python

```
def partition_backtrack(s):
    n = len(s)
    ans = []
    path = []

    def dfs(start_index):
        # 1. 终止条件：切割线切到了字符串末尾
        if start_index == n:
            # (可选) 某些题目需要判断切割段数是否符合要求（如IP地址必须4段）
            ans.append(path[:])  # 收集结果
            return

        # 2. 横向遍历：决定当前这一刀切多长
        # 这里的范围通常是 start_index 到 n，但也经常需要剪枝缩小范围
        for i in range(start_index, n):
            
            # 截取当前子串
            substring = s[start_index : i + 1]

            # 3. 剪枝/合法性判断：如果当前切出来的这块不行，就不要往后深搜了
            if not is_valid(substring):
                continue  # 或者 break，取决于题目逻辑
            
            # (可选) 题目特定的状态更新
            
            path.append(substring)  # 做选择
            dfs(i + 1)              # 递归：从切口 i+1 处开始切下一刀
            path.pop()              # 撤销选择

    dfs(0)
    return ans
```

---

### 三、 题目实战与差异点解析

根据你提供的六道题，我们可以将它们分为三个层级，主要的区别在于 **`is_valid` 的判断** 和 **状态传递**。

#### 1. 基础划分（检查当前段属性）

这类题目只关心当前切出来的这一段是否符合某种静态性质。

- **131. 分割回文串**
    
    - **切分逻辑**：枚举所有可能的结束位置。
        
    - **合法性**：`substring` 必须是回文串。
        
    - **优化**：可以使用 DP 预处理回文表 `dp[i][j]`，将判断回文的时间从 $O(N)$ 降为 $O(1)$。
        
- **93. 复原 IP 地址**
    
    - **切分逻辑**：每段长度只能是 1, 2, 3。
        
    - **合法性**：`0-255` 之间，且不能有前导 0。
        
    - **特殊限制**：必须切成 **4段**。需要在 Base Case 中检查 `len(path) == 4`，或者在递归参数中携带 `segment_count` 进行剪枝。
        

#### 2. 关联划分（当前段依赖上一段）

这类题目不仅要求当前段合法，还要求当前段和上一段有数值关系。

- **1849. 将字符串拆分为递减的连续值**
    
    - **状态传递**：DFS 需要多传一个参数 `pre_val`（上一个切出来的数值）。
        
    - **合法性**：`current_val == pre_val - 1`。
        
    - **剪枝技巧**：如果当前截取的数值已经大于 `pre_val`（因为是递减），直接 `break`，后面更长的肯定更大。
        
- **2698. 求一个整数的惩罚数**
    
    - **题目转化**：将数字 $i^2$ 的字符串形式进行划分，使得划分出的子数之和等于 $i$。
        
    - **状态传递**：DFS 需要携带 `current_sum`。
        
    - **合法性**：`current_sum + int(substring) <= target`。
        

#### 3. 全局最值/复杂结构（需要记忆化或特殊剪枝）

这类题目通常不是为了“找所有解”，而是“找最优解”或处理大规模数据。

- **1593. 拆分字符串使唯一子字符串的数目最大**
    
    - **目标**：求 `max(len(path))`。
        
    - **合法性**：`substring` 不能在 `set` 中出现过。
        
    - **剪枝（重要）**：如果 `当前已拆分数 + 剩余字符串最大可能拆分数 < 目前找到的最大答案`，直接剪枝。即 `len(path) + (n - start_index) <= max_ans`，直接 return。
        
- **140. 单词拆分 II**
    
    - **难点**：字符串很长，解非常多，存在大量重叠子问题（后缀相同）。
        
    - **必须优化**：**记忆化搜索（Memoization）**。
        
    - **做法**：`dfs(start_index)` 返回的是“从 start_index 开始能组成的所有句子列表”。如果算过这个 `start_index`，直接查表返回，否则会 TLE。
        

---

### 四、 优化与剪枝技巧汇总（精华）

在面试中，写出回溯是 60 分，加上剪枝才是 100 分。

1. **长度剪枝（最常用）**
    
    - **固定长度**：IP地址每段最多3位。循环 `range(start, min(start+3, n))`，不要无脑 `range(start, n)`。
        
    - **剩余长度**：如果要求切 4 段，现在切了 2 段，还剩 20 个字符，那肯定不行（每段最多3字符，2段最多6字符），直接剪掉。
        
2. **数值剪枝**
    
    - **范围溢出**：IP地址 `> 255`，直接 `break`（注意不是 continue，因为位数更多只会更大）。
        
    - **前导零**：如果 `s[start] == '0'`，那么当前段只能是 `"0"`，不能是 `"01"`, `"05"`。处理完 `"0"` 后直接 `break` 循环。
        
3. **逻辑剪枝**
    
    - **递减序列 (1849)**：如果 `当前数值 > 上一个数值`，直接 `break`（不用再往后找更长的了）。
        
    - **唯一性 (1593)**：如果当前子串已经存在于 `set` 中，`continue`。
        
4. **记忆化 (Memoization)**
    
    - 主要用于 **140. 单词拆分 II** 这类可能出现指数级解或者重叠子结构的问题。记录 `memo[start_index] = list_of_results`。
        

### 五、 总结思考导图

遇到字符串切分题，按这个流程 Check：

1. **是求什么？**
    
    - 求所有方案 -> 标准回溯 (131, 93)
        
    - 求是否可行/求最值 -> 也可以回溯，但优先考虑是否能贪心或动归 (1593)
        
    - 求组合具体内容但数据量大 -> 记忆化回溯 (140)
        
2. **约束是什么？**
    
    - 段内约束 (回文, 字典, 0-255) -> `check(substring)`
        
    - 段间约束 (递减, 求和) -> `dfs` 传参 `pre_val` 或 `current_sum`
        
3. **循环怎么写？**
    
    - 无脑 `start` 到 `n`？
        
    - 还是最多只看 3 位？
        
    - 遇到前导 0 怎么处理？
        

一句话总结：

划分型回溯就是枚举每一个可能的切割位置，把大字符串切成小字符串，关键在于利用题目给出的“合法性规则”尽早 break 循环，避免无效计算。