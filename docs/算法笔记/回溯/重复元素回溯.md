这是一个非常棒的总结需求。**回溯算法（Backtracking）的核心难点往往不在于递归本身，而在于如何优雅地去重**。

针对你列出的题目（90, 40, 491, 47），它们涵盖了“含重复元素”的所有典型场景。我们来构建一份**算法笔记**。

---

# 算法笔记：含重复元素的回溯去重

## 核心原则

在回溯树中，去重主要针对的是 **“树层去重” (Tree Level Deduplication)**。

- **树枝（纵向）**：代表递归深度，是同一个解里的元素组合。这里**允许**出现数值相同的元素（只要它们在数组中是不同的个体）。
    
- **树层（横向）**：代表在当前位置选择哪个元素。这里**不允许**连续选择数值相同的元素，因为会导致产生一模一样的分支。
    

## 场景分类与通用模板

我们将问题分为两类：**“可排序”** 和 **“不可排序”**。

### 1. 场景 A：可以排序 (90. 子集 II, 40. 组合总和 II, 47. 全排列 II)

如果题目求的是**组合**或**全排列**，元素的原始相对顺序不重要，或者题目允许打乱顺序，**必须先排序**。

- **准备工作**：`nums.sort()`
    
- **去重手段**：利用索引比较 `nums[i] == nums[i-1]`。
    

#### 写法一：枚举选哪个 (For 循环 / N叉树) —— **推荐**

这是最通用的写法，适用于子集、组合。

Python

```
# 核心代码片段
nums.sort() # 1. 必须排序

def dfs(start_index, path):
    # 收集结果 ...
    
    for i in range(start_index, len(nums)):
        # 【去重核心】
        # i > start_index 保证是“同层”比较，而不是“纵向”比较
        if i > start_index and nums[i] == nums[i-1]:
            continue 
            
        path.append(nums[i])
        dfs(i + 1, path)
        path.pop()
```

#### 写法二：选与不选 (Select / Not Select / 二叉树)

这种写法在处理去重时稍微麻烦一点，需要利用 `while` 跳过重复元素，或者用 `prev` 变量。

Python

```
nums.sort()

def dfs(i, path):
    if i == len(nums):
        res.append(path[:])
        return

    # --- 1. 选当前元素 ---
    path.append(nums[i])
    dfs(i + 1, path)
    path.pop()

    # --- 2. 不选当前元素 ---
    # 【去重核心】
    # 如果我不选当前的 nums[i]，那么后面所有等于 nums[i] 的我也都不能选
    # 否则会在“不选这个，选下一个”时生成重复子集
    while i + 1 < len(nums) and nums[i+1] == nums[i]:
        i += 1
    
    dfs(i + 1, path)
```

---

### 2. 场景 B：不可排序 (491. 非递减子序列)

如果题目求的是**子序列**，且要求保持原数组的相对顺序（如 LeetCode 491），则**绝对不能排序**。

- **准备工作**：不能动 `nums`。
    
- **去重手段**：使用 **哈希集合 (Set)** 记录本层使用过的元素。
    

Python

```
def dfs(start_index, path):
    if len(path) >= 2:
        res.append(path[:])
        
    # 【去重核心】
    # 每一层递归初始化一个新的 set，只负责当前层去重
    used_in_layer = set()
    
    for i in range(start_index, len(nums)):
        # 1. 剪枝：不满足题目特定条件 (如非递减)
        if path and nums[i] < path[-1]:
            continue
            
        # 2. 去重：本层已经用过这个数值了
        if nums[i] in used_in_layer:
            continue
            
        used_in_layer.add(nums[i]) # 记录
        
        path.append(nums[i])
        dfs(i + 1, path)
        path.pop()
```

---

### 3. 特殊场景：全排列 II (47. Permutations II)

全排列不需要 `start_index`，而是需要 `used/on_path` 数组标记哪些元素已被使用。

- **核心逻辑**：人为规定相同元素的**相对顺序**。
    
- **代码对比**：
    

|**没有重复元素 (46题)**|**有重复元素 (47题)**|
|---|---|
|`if used[i]: continue`|`if used[i]: continue`<br><br>  <br><br>`if i > 0 and nums[i] == nums[i-1] and not used[i-1]: continue`|

- **解释**：`not used[i-1]` 表示“前面的兄弟没被选”。如果前面的兄弟没被选，我（重复的弟弟）也不能先选，必须严格按照 `老大 -> 老二 -> 老三` 的顺序进入 `path`。
    

---

## 总结对比表 (Cheat Sheet)

|**题目类型**|**代表题号**|**能否排序**|**遍历方式**|**去重关键代码**|**备注**|
|---|---|---|---|---|---|
|**子集/组合**|90, 40|✅ 能|`for` 循环|`if i > start and nums[i] == nums[i-1]: continue`|最常用，利用排序物理相邻去重|
|**子集/组合**|90, 40|✅ 能|选/不选|只有在“不选”分支时：`while i+1 < n and nums[i+1]==nums[i]: i++`|逻辑稍繁琐，容易漏写|
|**子序列**|491|❌ 不能|`for` 循环|`uset = set(); if x in uset: continue`|空间换时间，每一层都要新 Set|
|**全排列**|47|✅ 能|`for` 循环|`if i>0 and nums[i]==nums[i-1] and not used[i-1]: continue`|树层去重，强制同值元素的相对顺序|

## 给你的建议

1. **首选 For 循环写法**：除非题目强制要求某些特殊逻辑，否则解决子集、组合、排列问题时，优先使用 `For` 循环（N叉树）模型。这种模型中，`i > start` 配合 `nums[i] == nums[i-1]` 的去重逻辑是最清晰的。
    
2. **死记 47 题逻辑**：全排列的去重逻辑 `not used[i-1]` 比较独特，建议把它当做一个固定公式背下来。
    
3. **491 是特例**：遇到“子序列”且不能排序时，立刻反应出“需要用 Set 去重”。
    

这份笔记可以作为你复习回溯算法重复元素问题的纲领。如果能把这几个代码片段默写出来，这类题目就通关了。