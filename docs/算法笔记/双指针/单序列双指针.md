

## 核心代码

```python

class Solution:

    def reverseSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:

        l, r = x, x + k - 1

        while l < r:

            for j in range(y, y + k):

                grid[l][j], grid[r][j] = grid[r][j], grid[l][j]

            l += 1

            r -= 1

        return grid

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意反转范围，反转写l< r





## 核心代码

```python

class Solution:

    def reverseStr(self, s: str, k: int) -> str:

        s = list(s)

        for i in range(0,len(s),k * 2):

            s[i:i + k] = s[i:i + k][::-1]

        return "".join(s)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意研究题意，python切片剩下索引不够自动取完





## 核心代码

```python

class Solution:

    def reverseVowels(self, s: str) -> str:

        s = list(s)

        i,j = 0,len(s) - 1

        while i < j:

            while i < j and s[i] not in "aeiouAEIOU":

                i += 1

            while i < j and s[j] not in "aeiouAEIOU":

                j -= 1

            s[i],s[j] = s[j],s[i]

            i += 1

            j -= 1

        return "".join(s)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意内部找到满足条件的字母交换时，也要满足i < j



## 核心代码

```python

class Solution:

    def isPalindrome(self, s: str) -> bool:

        i,j = 0,len(s) - 1

        while i < j:

            while i < j and not s[i].isalnum():

                i += 1

            while i < j and not s[j].isalnum():

                j -= 1

            if s[i].lower() == s[j].lower():

                i += 1

                j -= 1

            else:

                return False

        return True
        
        
        
class Solution:
def isPalindrome(self, s: str) -> bool:
	i, j = 0, len(s) - 1
	while i < j:
		if not s[i].isalnum():
			i += 1
		elif not s[j].isalnum():
			j -= 1
		elif s[i].lower() == s[j].lower():
			i += 1
			j -= 1
		else:
			return False
	return True

```


##  核心结论 (One-Liner)

> [!summary] 本题考点
> 两种写法，第二种更直观一点，找到左边第一个有效字符，找到右边第一个有效字符，然后比较第一种当然也行，每次只进行一次操作，只走一步




## 核心代码

```python


class Solution:

    def minimumLength(self, s: str) -> int:

        i,j = 0,len(s) - 1

        while i < j and s[i] == s[j]:

            c = s[i]

            while i <= j and s[i] == c:

                i += 1

            while i <= j and s[j] == c:

                j -= 1

        return j - i + 1
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
>相等区间的下一位需要另外用一个变量记录相等值，然后往后找到第一个不等的点



## 核心代码

```python

class Solution:

    def sortedSquares(self, nums: List[int]) -> List[int]:

        ans = [0] * len(nums)

        i,j = 0,len(nums) - 1

        k = len(nums) - 1

        while i <= j:

            if nums[i] + nums[j] >= 0:

                ans[k] = nums[j] * nums[j]

                k -= 1

                j -= 1

            else:

                ans[k] = nums[i] * nums[i]

                k -= 1

                i += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意写法，外层循环也可以是倒序遍历，一次填最大的






















