二、二分答案
“花费一个 log 的时间，增加了一个条件。” —— 二分答案

§2.1 求最小
题目求什么，就二分什么。

答疑
问：如何把二分答案与数组上的二分查找联系起来？

答：假设答案在区间 [2,5] 中，我们相当于在一个虚拟数组 [check(2),check(3),check(4),check(5)] 中二分找第一个（或者最后一个）值为 true 的 check(x)。这同样可以用红蓝染色法思考。

问：有些题目，明明 m 可以是答案，但却不在初始二分区间中。比如闭区间二分初始化 right=m−1（或者开区间 right=m），这不会算错吗？

答：不会算错。注意「答案所在区间」和「二分区间」是两个概念。想一想，如果二分的 while 循环每次更新的都是 left，那么最终答案是什么？正好就是 m。一般地，如果一开始就能确定 m 一定可以满足题目要求，那么 m 是不需要在二分区间中的。换句话说，二分区间是「尚未确定是否满足题目要求」的数的范围。那些在区间外面的数，都是已确定的满足（不满足）题目要求的数。

问：什么是循环不变量？

答：想一想，对于求最小的题目，开区间二分的写法，为什么最终返回的是 right，而不是别的数？在初始化（循环之前）、循环中、循环结束后，都时时刻刻保证 check(right) == true 和 check(left) == false，这就叫循环不变量。根据循环不变量，循环结束时 left+1=right，那么 right 就是最小的满足要求的数（因为再 −1 就不满足要求了），所以答案是 right。

注：部分题目可以优化二分边界，减少二分次数，从而减少代码运行时间。对于初次接触二分答案的同学，无需强求自己写出最优的代码，设定一个比较大的二分上界也是可以的。

开区间二分模板（求最小）：

``` python
class Solution: 
# 计算满足 check(x) == True 的最小整数 x 
def binarySearchMin(self, nums: List[int]) -> int: 
# 二分猜答案：判断 mid 是否满足题目要求 
	def check(mid: int) -> bool: 
	# TODO 
	left = # 循环不变量：check(left) 恒为 False 
	right = # 循环不变量：check(right) 恒为 True 
	while left + 1 < right: # 开区间不为空 
		mid = (left + right) // 2 
		if check(mid): # 说明 check(>= mid 的数) 均为 True 
			right = mid # 接下来在 (left, mid) 中二分答案 
		else: # 说明 check(<= mid 的数) 均为 False 
			left = mid # 接下来在 (mid, right) 中二分答案 
	# 循环结束后 left+1 = right 
	# 此时 check(left) == False 而 check(left+1) == check(right) == True 
	# 所以 right 就是最小的满足 check 的值 
	return right 

```




## 核心代码

```python

class Solution:

    def smallestDivisor(self, nums: List[int], threshold: int) -> int:

        left = 0

        right = max(nums)

        n = len(nums)

        while left + 1 < right:

            mid = left + (right - left) // 2

            if sum((x - 1) // mid for x in nums) <= threshold - n:

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 假设除数为m 式子有单调性 看我们假设的这个数越大越满足条件还是越小越满足条件
> 在练习时，请注意「求最小」和「求最大」的二分写法上的区别。
「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。
「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。以开区间二分为例：
求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。
求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。
对于开区间写法，简单来说 check(mid) == true 时更新的是谁，最后就返回谁。相比其他二分写法，开区间写法不需要思考加一减一等细节，个人推荐使用开区间写二分。




## 核心代码

```python

class Solution:

    def minimumTime(self, time: List[int], totalTrips: int) -> int:

        left,right = 0 ,min(time) * totalTrips

        while left + 1 < right:

            mid = left + (right - left) // 2

            if sum(mid // t for t in time) >= totalTrips:

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意check条件和两边条件，到这还没出现初始区间问题，依然求最小，就更新right，check right 为TRUE 那么最开始的时候right是否为True再思考



## 核心代码

```python

class Solution:

    def shipWithinDays(self, weights: List[int], days: int) -> int:

        left = max(weights) - 1

        right = sum(weights)

        def check(m):

            ans = 1

            s = 0

            for w in weights:

                s += w

                if s > m:

                    ans += 1

                    s = w

            return ans <= days

        while left + 1 < right:

            mid = left + (right - left) // 2

            if check(mid):

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意搜索区间，上下界的设定，check函数也是根据这个来写的




## 核心代码

```python

class Solution:

    def minEatingSpeed(self, piles: List[int], h: int) -> int:

        left,right = 0,max(piles)

        while left + 1 < right:

            mid = left + (right - left) // 2

            if sum((p - 1) // mid for p in piles) <= h - len(piles):

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 求最小值，右端点必定满足，左端点必定不满足，因为我们是开区间 确定二分范围很重要




## 核心代码

```python

class Solution:

    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:

        left = 0

        right = min(workerTimes) * (mountainHeight + 1) * mountainHeight // 2

        def check(m):

            left_h = mountainHeight

            for t in workerTimes:

                left_h -= (isqrt(m // t * 8 + 1) - 1) // 2

                if left_h <= 0:

                    return True

            return False

        while left + 1 < right:

            mid = left + (right - left) // 2

            if check(mid):

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> check函数可能数学推导有点难写，其他思路照常
> 最小值 check right true left false 寻找二分区间 






## 核心代码

```python

class Solution:

    def minTime(self, s: str, order: List[int], k: int) -> int:

        n = len(s)

        if n * (n + 1) // 2 < k:

            return -1

        star = [0] * n

        def check(m):

            m += 1

            for j in range(m):

                star[order[j]] = m

            cnt = 0

            last = -1

            for i,x in enumerate(star):

                if x == m:

                    last = i

                cnt += last + 1

                if cnt >= k:

                    return True

            return False

        left,right = -1,n - 1

        while left + 1 < right:

            mid = left + (right - left) // 2

            if check(mid):

                right = mid

            else:

                left = mid

        return right

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 找上一个指定值出现的坐标，last = -1，循环里面如果找到，last = 对应索引
> 枚举字符串的所有子字符串，枚举右端点，以右端点结尾的子字符串有下标加1个
> 特判情况 然后一定满足要求，需要注意
> ```py
star = [0] * n  # 避免在二分内部反复创建/初始化列表




































