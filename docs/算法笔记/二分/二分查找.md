# 一、二分查找

**讲解**：二分查找 红蓝染色法【基础算法精讲 04】
**来源**：[灵茶山艾府 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/SqopEo/)

**前提设定**：设 `nums` 为递增（非递减）数组，长度为 `n`。
**核心定义**：`lowerBound(nums, target)` 表示查找数组中 **$\ge target$ 的第一个元素**的下标。

**python 接口**
**bisect_left(nums,target,low,upper,key = check) >=**
**bisect_right(nums,taeget,low,upper,key = check) >**

## 1. 查找元素下标转换表

| 需求 | 写法 | 如果不存在 |
| :--- | :--- | :--- |
| $\ge x$ 的第一个元素的下标 | `lowerBound(nums, x)` | 结果为 `n` |
| $> x$ 的第一个元素的下标 | `lowerBound(nums, x+1)` | 结果为 `n` |
| $< x$ 的最后一个元素的下标 | `lowerBound(nums, x) - 1` | 结果为 `-1` |
| $\le x$ 的最后一个元素的下标 | `lowerBound(nums, x+1) - 1` | 结果为 `-1` |

> **提示**：针对整数数组，$> x$ 等价于 $\ge x+1$，$\le x$ 等价于 $< x+1$。

## 2. 统计元素个数转换表

| 需求 | 写法 |
| :--- | :--- |
| $< x$ 的元素个数 | `lowerBound(nums, x)` |
| $\le x$ 的元素个数 | `lowerBound(nums, x+1)` |
| $\ge x$ 的元素个数 | `n - lowerBound(nums, x)` |
| $> x$ 的元素个数 | `n - lowerBound(nums, x+1)` |

> **注意**：
> *   $< x$ 和 $\ge x$ 互为补集，元素个数之和为 `n`。
> *   $\le x$ 和 $> x$ 同理，元素个数之和为 `n`。


注意，算法找到第一个>= 的数，要判断 

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

## 核心代码

```python

class Solution:

    def searchRange(self, nums: List[int], target: int) -> List[int]:

        i = bisect_left(nums,target)

        j = bisect_right(nums,target) - 1

        if i != len(nums) and nums[i] == target:

            return [i,j]

        return [-1,-1]

```

##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意是找的第一个>=x的数，要判断会不会超出数组范围以及值是否等于targert ，处理查找指定值的情况




## 核心代码

```python
class Solution:

    def nextGreatestLetter(self, letters: List[str], target: str) -> str:

        i = bisect_right(letters, target)

        if i == len(letters):

            return letters[0]

        return letters[i]


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 字母也可以直接比较，注意right是 找到  > 的第一个位置





## 核心代码

```python

class Solution:

    def maximumCount(self, nums: List[int]) -> int:

        n = len(nums)

        i = bisect_left(nums,0)

        j = bisect_right(nums,0)

        return max(i,n - j)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 二分查找左的下标就是左边数的个数，也是<查找数的个数，二分查找右的下标j n - j代表大于查找数的个数






## 核心代码

```python
class Solution:

    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:

        arr2.sort()

        ans = 0

        for x in arr1:

            i = bisect_left(arr2,x - d)

            if i == len(arr2) or arr2[i] > x + d:

                ans += 1

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 查找后一定要记住检查边界，不一定查找的到




## 核心代码

```python
class Solution:

    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:

        nums.sort()

        for i in range(1,len(nums)):

            nums[i] += nums[i - 1]

        for qi,q in enumerate(queries):

            queries[qi] = bisect_right(nums,q)

        return queries


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 遍历有技巧，对于一个查询，在另外的数组遍历或查找，必要时可排序（子序列不需要相对顺序） 查找时注意要找什么




## 核心代码

```python
a = sorted(s.count(min(s)) for s in words)
return [len(a) - bisect_right(a, q.count(min(q))) for q in queries]


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 想操作数组后排序，可用sorted函数，然后注意查找时满足条件的是哪一部分  f(w) > f(q),直接题意来就行，找后面部分  因为在w里找q注意



## 核心代码

```python

class Solution:

    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:

        potions.sort()

        return [len(potions) - bisect_left(potions,(success - 1) // p + 1) for p in spells]
        
问题相当于给你 n 个询问，每次问 spells[i] 与 potions 中的多少个数相乘，结果 ≥success。

对 potions 排序后，就可以二分查找了：

设 j 是最小的满足 potions[j]≥ spells[i]success的下标。
由于数组已经排序，那么下标大于 j 的数也同样满足不等式。
从 j 到 m−1，一共有 m−j 个满足不等式的数，其中 m 是 potions 的长度。        


```
##  核心结论 (One-Liner)



> [!summary] 本题考点
> 排序是核心，注意在哪个数组里查找，转化为数组里的数满足什么条件，向上取整转化为减1后向下取整 再整体值加1   三步走思考也很不错，设j是满足条件的最小下标    





## 核心代码

```python

class RangeFreqQuery:

  

    def __init__(self, arr: List[int]):

        pos = defaultdict(list)

        for i,x in enumerate(arr):

            pos[x].append(i)

        self.pos = pos

  

    def query(self, left: int, right: int, value: int) -> int:

        q = self.pos[value]

        l = bisect_left(q,left)

        r = bisect_right(q,right)

        return r - l

  
  

# Your RangeFreqQuery object will be instantiated and called as such:

# obj = RangeFreqQuery(arr)

# param_1 = obj.query(left,right,value)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 对于每一个值存下标是个常见的方法，主要用于重复值的之间的个数查找和相互之间的距离
> 注意一定要想到，方法很常见



## 核心代码

```python
class Solution:

    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:

        pos = defaultdict(list)

        for i,x in enumerate(nums):

            pos[x].append(i)

        n = len(nums)

        for q in pos.values():

            i0 = q[0]

            q.insert(0,q[-1] - n)

            q.append(i0 + n)

        for qi,q in enumerate(queries):

            p = pos[nums[q]]

            if len(p) == 3:

                queries[qi] = -1

            else:

                i = bisect_left(p,q)

                queries[qi] = min(q - p[i - 1],p[i + 1] - q)

        return queries


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 哨兵逻辑很棒，注意下标数组和查找下标数组得到的下标有差距，二分查找拿到的下标一定要弄清楚意思，在哪查找的，这里同样和上个题用的一样的方法，需要注意，处理循环数组或许还有更多的办法，需要积累







## 核心代码

```python
class Solution:

    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:

        nums.sort()

        ans = 0

        for j,x in enumerate(nums):

            r = bisect_right(nums,upper - x,0,j)

            l = bisect_left(nums,lower - x,0,j)

            ans += r - l

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 枚举右，二分查找左满足的区间，跟区间内查找数的频率有点像，比那个题多了一个枚举右，然后找左边数满足的区间



## 核心代码

```python
class Solution:

    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:

        items.sort(key = lambda x:x[0])

        for i in range(1,len(items)):

            if items[i][1] < items[i - 1][1]:

                items[i][1] = items[i - 1][1]

        for qi,q in enumerate(queries):

            j = bisect_right(items,q,key = lambda item:item[0]) - 1

            queries[qi] = items[j][1] if j >= 0 else 0

        return queries


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 前缀最大值需要注意，二分查找对多维数组也可传入check


	

## 核心代码

```python
class SnapshotArray:

  

    def __init__(self, length: int):

        pos = defaultdict(list)

        self.pos = pos

        self.snap_id = 0

  

    def set(self, index: int, val: int) -> None:

        self.pos[index].append((self.snap_id,val))

  

    def snap(self) -> int:

        self.snap_id += 1

        return self.snap_id - 1    

  

    def get(self, index: int, snap_id: int) -> int:

        p = self.pos[index]

        j = bisect_left(p,(snap_id + 1,)) - 1

        return self.pos[index][j][1] if j >= 0 else 0




```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 元组可以比较，但要注意比较细节
```php
 # 等价于找快照编号 >= snap_id + 1 的第一个修改记录，它的上一个就是答案
        j = bisect_right(self.history[index], (snap_id + 1,)) - 1
        # 更直观：找到 snap_id 的“右边界”，然后取前一个
        # 不能直接用 bisect_right(self.history[index], (snap_id,))，
        # 因为元组比较的细节， (snap_id,) < (snap_id, val)，会导致插入位置错误
```


## 核心代码

```python
class Solution:

    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:

        right = bisect_left(arr,x)

        left = right - 1

        for _ in range(k):

            if left < 0:

                right += 1

            elif right >= len(arr) or x - arr[left] <= arr[right] - x:

                left -= 1

            else:

                right += 1

        return arr[left + 1:right]


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意结束后答案区间在哪



## 核心代码

```python
class Solution:

    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:

        mod = 10 ** 9 + 7

        mx = 0

        n = len(nums1)

        s = sum(abs(x - y) for x,y in zip(nums1,nums2))

        p = sorted(nums1)

        for x,y in zip(nums1,nums2):

            cur_diff = abs(x - y)

            j = bisect_left(p,y)

            if j < n:

                mx = max(mx,cur_diff - abs(p[j] - y))

            if j:

                mx = max(mx,cur_diff - abs(p[j - 1] - y))

        return (s - mx) % mod


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 拿到排序数组要用sorted，sort函数不返回值



## 核心代码

```python
class Solution:
    def getTriggerTime(self, increase: List[List[int]], requirements: List[List[int]]) -> List[int]:
        n = len(increase)
        # 分别存储三个属性的前缀和
        prefix_c = [0] * (n + 1)
        prefix_r = [0] * (n + 1)
        prefix_h = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_c[i] = prefix_c[i-1] + increase[i-1][0]
            prefix_r[i] = prefix_r[i-1] + increase[i-1][1]
            prefix_h[i] = prefix_h[i-1] + increase[i-1][2]
        
        result = []
        # 对每个requirement并行处理
        for c_req, r_req, h_req in requirements:
            # 分别找到满足每个条件的最小天数
            i = bisect.bisect_left(prefix_c, c_req)
            j = bisect.bisect_left(prefix_r, r_req)
            k = bisect.bisect_left(prefix_h, h_req)
            
            # 取最大值，因为需要同时满足三个条件
            t = max(i, j, k)
            if t <= n:
                result.append(t)
            else:
                result.append(-1)
        
        return result
```

##  核心结论 (One-Liner)

> [!summary] 本题考点
> 预处理前缀和，用三个数组











































