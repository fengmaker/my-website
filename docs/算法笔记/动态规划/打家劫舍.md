这是一份关于 **“打家劫舍” (House Robber)** 系列问题的算法笔记总结。这类问题是动态规划（DP）中非常经典的模型，核心在于**“在限制条件下（通常是不相邻）进行选择以最大化收益”**。

---

# 打家劫舍系列 DP 算法笔记

## 1. 核心思维模型 (The Core Pattern)

所有打家劫舍类问题的本质可以归纳为：

- **状态定义**：$dp[i]$ 表示前 $i$ 个元素能获得的最大收益。
    
- **选择策略**：对于当前元素 $nums[i]$，只有两种选择：
    
    1. **偷 (选)**：那么第 $i-1$ 个不能选，收益为 $nums[i] + dp[i-2]$（或更早的合法状态）。
        
    2. **不偷 (不选)**：那么收益继承自 $dp[i-1]$。
        
- 状态转移方程：
    
    $$dp[i] = \max(dp[i-1], \quad dp[i-2] + nums[i])$$
    

### 通用代码模版 (空间优化 $O(1)$)

由于 $dp[i]$ 只依赖于前两个状态，我们可以用两个变量滚动更新，无需 $O(N)$ 空间。

Python

```
def rob_template(nums: List[int]) -> int:
    prev = 0  # dp[i-2]
    curr = 0  # dp[i-1]
    
    for x in nums:
        # 新的 curr = max(不偷当前, 偷当前 + dp[i-2])
        # Python 支持并行赋值，无需临时变量
        prev, curr = curr, max(curr, prev + x)
        
    return curr
```

---

## 2. 题目变体与解题思路

我们将你列出的题目分为四类变体进行解析：

### 第一类：基础与环形 (Basic & Circular)

**题目**：198 (基础), 213 (环形)

- **198. 打家劫舍**：直接套用上述模版。
    
- **213. 打家劫舍 II**：
    
    - **难点**：数组首尾相连，选了第一个就不能选最后一个。
        
    - **破局思路**：**拆解环**。将问题拆分为两个单排打家劫舍问题，取最大值。
        
        1. 偷范围 `[0, n-2]` (一定不包含尾)
            
        2. 偷范围 `[1, n-1]` (一定不包含首)
            
    - **代码简记**：`return max(rob(nums[:-1]), rob(nums[1:]))` (注意处理 len=1 的特例)。
        

### 第二类：值域转换 (Value Transformation)

**题目**：740 (删除并获得点数), 3186 (施咒最大伤害)

这类题目给出的数组并不是“房子”，而是“数字”。限制条件是数值上的相邻（如选了 $x$，不能选 $x-1$ 或 $x+1$）。

- **740. 删除并获得点数**：
    
    - **转化**：将原数组转化为“房子数组”。统计每个数字 $x$ 出现的总点数 `sum[x] = x * count[x]`。
        
    - **思路**：如果 `sum` 数组的下标代表数字 $x$，那么选了下标 $x$，就不能选 $x-1$ 和 $x+1$。这完全等价于打家劫舍。
        
    - **技巧**：构造一个大小为 `max(nums)+1` 的数组，然后跑基础模版。
        
- **3186. 施咒的最大总伤害** (变种：选 $x$, 不能选 $x-1, x-2, x+1, x+2$)：
    
    - **难点**：数据范围可能很大或稀疏，构造 $10^9$ 大小的数组会 MLE/TLE；且禁选范围扩大到了 $\pm 2$。
        
    - **思路**：
        
        1. **分组排序**：对 `nums` 进行计数并去重排序，得到 `unique_nums` 和对应的总伤害。
            
        2. **二分查找 (Binary Search)**：由于不是简单的 $i-1$ 和 $i-2$，我们需要找到**上一个合法的下标** $j$，满足 `unique_nums[j] < unique_nums[i] - 2`。
            
        3. **转移方程**：$dp[i] = \max(dp[i-1], \quad \text{current\_damage} + dp[j])$。
            
    - **关键点**：使用 `bisect_left` 快速定位合法的 $j$。
        

### 第三类：组合计数与独立性 (Combinatorics)

**题目**：2320 (统计放置房子的方式数)

- **思路**：
    
    - 题目是统计方案数，不是求最大值。
        
    - 街道两侧互不影响。
        
    - **单侧逻辑**：如果不限制房子数量，每个位置放或不放且不相邻，这其实是**斐波那契数列**。
        
        - 放 $i$：方案数 = $dp[i-2]$
            
        - 不放 $i$：方案数 = $dp[i-1]$
            
        - $dp[i] = dp[i-1] + dp[i-2]$
            
    - **最终结果**：$Total = (Side_{ways} \times Side_{ways}) \pmod {MOD}$。
        

### 第四类：思维扩展 - 跳跃与决策 (Skip Steps)

**题目**：2140 (解决智力问题)

- **特点**：这道题更像背包问题或打家劫舍的广义版。打家劫舍是固定冷却时间为 1，这里冷却时间由 `nums[i]` 决定。
    
- **方向选择**：**倒序 DP (Backward DP)** 通常比正序更好写。
    
    - 如果我们从后往前看：
        
    - 对于第 $i$ 题：
        
        1. **做**：获得 `points[i]`，下一题必须跳到 `i + brainpower[i] + 1`。
            
        2. **不做**：收益等于 `dp[i+1]`。
            
    - $dp[i] = \max(dp[i+1], \quad points[i] + dp[\min(n, i + jump + 1)])$。
        

---

## 3. 思考技巧与总结 (Tips & Tricks)

1. **识别题目特征**：
    
    - 只要看到关键词“**选择最大化**” + “**不能选相邻/特定邻域**”，立刻联想打家劫舍。
        
    - 如果相邻定义在“下标”上 $\rightarrow$ 标准版。
        
    - 如果相邻定义在“数值”上 $\rightarrow$ 排序/哈希表 + DP。
        
2. **空间优化**：
    
    - 大多数此类问题只需要 $prev$ 和 $curr$ 两个变量，不需要完整的 DP 数组。
        
3. **处理“稀疏”数据 (针对 740 vs 3186)**：
    
    - 如果数值密集且范围小（如 740，max=10000），直接开数组映射下标，简单粗暴。
        
    - 如果数值稀疏或范围大（如 3186），**排序 + 去重 + 二分查找**找前驱状态是标准解法。
        
4. **正序 vs 倒序**：
    
    - 对于固定间隔（如 $i-1, i-2$），正序很顺手。
        
    - 对于**非固定跳跃**（如 2140），或者依赖“未来”状态的问题，倒序 DP 往往能避免越界判断，逻辑更清晰。
        

### 针对你提到的 3186 (施咒) 的 Python 简洁实现参考：

这道题是这个系列中逻辑最复杂的一个，融合了排序和二分。

Python

```
def maximumTotalDamage(self, power: List[int]) -> int:
    from collections import Counter
    import bisect

    cnt = Counter(power)
    # 去重并排序
    uniq = sorted(cnt.keys())
    n = len(uniq)
    
    # dp[i] 表示考虑前 i 个唯一数值能获得的最大伤害
    # 为了方便处理边界，dp 数组大小设为 n + 1
    dp = [0] * (n + 1)
    
    for i in range(n):
        val = uniq[i]
        damage = val * cnt[val]
        
        # 核心：找到上一个可以共存的位置 j
        # 我们需要找到一个索引，使得 uniq[idx] < val - 2
        # bisect_left 找的是第一个 >= val - 2 的位置，所以该位置左边的就是 < val - 2
        j = bisect.bisect_left(uniq, val - 2)
        
        # 状态转移：
        # 1. 不选当前 val -> dp[i] (对应 dp 数组下标 i+1 的前一个，即 dp[i])
        # 2. 选当前 val -> damage + dp[j]
        dp[i+1] = max(dp[i], damage + dp[j])
        
    return dp[n]
```

下一步建议：

你已经掌握了这一类题目的核心。建议去尝试一下 “树形 DP 中的打家劫舍”，即 337. 打家劫舍 III。这会将线性 DP 的思维升级到二叉树上（选父节点 vs 选子节点），是面试中非常高频的变体。需要我为你解析这道题吗？