这是一份针对你所列题目的**线性 DP（爬楼梯系列）**深度总结笔记。

从最基础的斐波那契数列，到带权重的、变步长的、甚至组合数类的变种，其核心始终围绕着**“当前状态如何从过去有限的几个状态推导而来”**。

---

### 第一部分：题目演进与代码对比

#### 1. [70] 爬楼梯 (基础)

**核心**：$f(i) = f(i-1) + f(i-2)$，纯加法。

- **记忆化搜索 (Top-Down)**
    

Python

```
class Solution:
    def climbStairs(self, n: int) -> int:
        @cache
        def dfs(i):
            if i == 0: return 1 # 成功到达（或原地不动算一种）
            if i < 0: return 0  # 越界
            return dfs(i - 1) + dfs(i - 2)
        return dfs(n)
```

- **空间优化 (Bottom-Up)**
    
    - 窗口大小：2。使用 `a, b` 滚动。
        

Python

```
class Solution:
    def climbStairs(self, n: int) -> int:
        a, b = 1, 1 # f(0)=1, f(1)=1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
```

---

#### 2. [746] 使用最小花费爬楼梯 (带权)

**核心**：$dp[i] = \min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])$。

- **记忆化搜索**
    

Python

```
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        @cache
        def dfs(i):
            if i <= 1: return 0 # 0和1级台阶可以作为起点，花费为0
            return min(dfs(i - 1) + cost[i - 1], dfs(i - 2) + cost[i - 2])
        return dfs(n)
```

- **空间优化**
    
    - 窗口大小：2。
        

Python

```
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        f0, f1 = 0, 0
        for i in range(2, len(cost) + 1):
            # 这里的 new_f 就是到达当前层的最小花费
            new_f = min(f1 + cost[i - 1], f0 + cost[i - 2])
            f0, f1 = f1, new_f
        return f1
```

---

#### 3. [3693] 爬楼梯 II (自定义规则)

**核心**：$dp[i] = \min_{j}(dp[j] + (i-j)^2) + cost[i-1]$，回顾前 3 步。

- **记忆化搜索**
    

Python

```
class Solution:
    def climbStairsII(self, n: int, costs: List[int]) -> int:
        @cache
        def dfs(i):
            if i == 0: return 0
            if i < 0: return float('inf')
            # 尝试回退 1, 2, 3 步，加上跳跃罚分
            res = min(dfs(i-1)+1, dfs(i-2)+4, dfs(i-3)+9)
            return res + costs[i-1]
        return dfs(n)
```

- **空间优化**
    
    - 窗口大小：3。需要 `f0, f1, f2`。
        

Python

```
class Solution:
    def climbStairsII(self, n: int, costs: List[int]) -> int:
        # 初始化：假设 f2 是起点 0。
        # f0, f1 代表负数台阶，设为无穷大避免被选中
        f0 = f1 = float('inf')
        f2 = 0 
        
        for c in costs: # 遍历每一级台阶的费用
            new_f = min(f2 + 1, f1 + 4, f0 + 9) + c
            f0, f1, f2 = f1, f2, new_f
        return f2
```

---

#### 4. [377] 组合总和 Ⅳ (排列数)

**核心**：步长不固定，由 `nums` 数组决定。$dp[i] = \sum dp[i - num]$。

- **记忆化搜索**
    

Python

```
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def dfs(i):
            if i == 0: return 1
            if i < 0: return 0
            return sum(dfs(i - x) for x in nums)
        return dfs(target)
```

- **空间优化 (注意：这里很难 O(1))**
    
    - **为什么不能简单的滚动？** 因为 `nums` 里的数可能很大，比如 `[1, 100]`，你需要回顾到 100 步之前的状态。窗口大小取决于 `max(nums)`，通常直接用一维 DP 数组。
        

Python

```
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)
        dp[0] = 1 # 只有一种方式组成0（空集）
        
        for i in range(1, target + 1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
        return dp[target]
```

---

#### 5. [2466] 统计构造好字符串的方案数

**核心**：每次只能增加 `zero` 个 0 或 `one` 个 1。本质就是步长为 `zero` 和 `one` 的爬楼梯。

- **记忆化搜索**
    

Python

```
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 10**9 + 7
        @cache
        def dfs(i):
            if i > high: return 0
            res = 1 if i >= low else 0 # 只有在 [low, high] 区间内才计数
            res += dfs(i + zero) + dfs(i + one)
            return res % MOD
        return dfs(0)
```

- **迭代写法 (数组)**
    
    - 这里为了求和方便，通常正向 DP。
        

Python

```
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0] * (high + 1)
        dp[0] = 1
        MOD = 10**9 + 7
        
        for i in range(1, high + 1):
            if i >= zero: dp[i] = (dp[i] + dp[i - zero]) % MOD
            if i >= one:  dp[i] = (dp[i] + dp[i - one]) % MOD
            
        return sum(dp[low:]) % MOD
```

---

#### 6. [2266] 统计打字方案数

**核心**：按键对应步长为 3 (普通) 或 4 (7/9键)。

- **记忆化搜索**
    

Python

```
class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        MOD = 10**9 + 7
        n = len(pressedKeys)
        @cache
        def dfs(i):
            if i == n: return 1
            res = 0
            # 尝试截取长度为 1, 2, 3, (4) 的子串
            max_len = 4 if pressedKeys[i] in "79" else 3
            for k in range(max_len):
                if i + k < n and pressedKeys[i+k] == pressedKeys[i]:
                    res = (res + dfs(i + k + 1)) % MOD
                else:
                    break
            return res
        return dfs(0)
```

- **空间优化 (分组 + 滚动)**
    
    - 这题的特点是：由不同数字组成的段落是互相独立的（乘法原理）。我们可以分别计算每一段连续相同字符的方案数，再乘起来。
        
    - 对于每一段，就是爬楼梯问题。
        

Python

```
class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        MOD = 10**9 + 7
        ans = 1
        # 预计算爬楼梯数组 f (步长3) 和 g (步长4)
        # 此处省略预计算代码，参考之前的对话
        
        for ch, group in groupby(pressedKeys):
            length = len(list(group))
            # 直接查表 O(1)
            ans = (ans * (g[length] if ch in "79" else f[length])) % MOD
        return ans
```

---

### 第二部分：核心方法论总结

#### 1. 什么时候可以“滚动计算”？什么时候必须“枚举下标”？

|**判据**|**滚动变量 (Rolling Variables)**|**数组枚举 (Array Iteration)**|
|---|---|---|
|**依赖范围**|**固定且短小** (Fixed Window)|**动态或很长** (Dynamic Window)|
|**例子**|$f(i)$ 只依赖 $i-1, i-2, i-3$|$f(i)$ 依赖 $i-k$，其中 $k \in \text{nums}$|
|**代码特征**|`a, b, c = b, c, new_val`|`dp[i] += dp[i - num]`|
|**空间复杂度**|$O(1)$|$O(N)$ 或 $O(\max(\text{nums}))$|

- **特例**：即使依赖范围很长（比如前 100 个），如果你想极致省空间，可以使用 **循环数组 (Circular Buffer)** 来实现 $O(K)$ 的空间，但这通常增加了代码复杂度，面试中不如直接开 $O(N)$ 数组清晰。
    

#### 2. 转移方程的边界如何思考？

这是一个“定义起点”的问题。你需要问自己两个问题：

**Q1: 这里的“0”代表什么？**

- **求方案数 (Count)**：`dp[0] = 1`。
    
    - 物理意义：凑出总和为 0 的方案只有一种，就是“什么都不选”（空集）。它是乘法的单位元。
        
- **求最小值 (Min Cost)**：`dp[0] = 0`。
    
    - 物理意义：站在起点不需要花费。
        
- **求最大值 (Max Profit)**：`dp[0] = 0`。
    

**Q2: 越界了怎么办？(i < 0)**

- **求方案数**：返回 `0`。
    
    - 此路不通，贡献为 0。
        
- **求最小值**：返回 `inf` (正无穷)。
    
    - 让 `min()` 函数永远不要选中这条死路。
        
- **求最大值**：返回 `-inf` (负无穷)。
    
    - 让 `max()` 函数永远不要选中这条死路。
        

#### 3. 快速从 DFS 映射到 DP 的口诀

1. **看参数**：DFS 有几个变化的参数，DP 表就是几维。
    
2. **看循环**：DFS 里 `for x in nums`，DP 里就是内层循环 `for x in nums`。
    
3. **看方向**：
    
    - DFS 是 `i` 找 `i-1, i-2` (自顶向下)。
        
    - DP 循环通常是从 `0` 到 `n` (自底向上)。
        
    - **滚动优化技巧**：如果 DP 只用了 `dp[i-1]` 和 `dp[i-2]`，把 `dp` 数组扔掉，直接定义 `pre`, `cur` 两个变量即可。
        

这套笔记覆盖了你提到的所有题目，从基础到进阶，应该能帮你建立起很稳固的爬楼梯类 DP 知识体系。