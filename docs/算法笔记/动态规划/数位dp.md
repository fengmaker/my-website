这份 **数位 DP (Digit DP) 算法笔记** 旨在帮助你从“会写”进阶到“精通”，涵盖了你刚才练习的所有核心考点。

---

# 📚 数位 DP 算法笔记

## 一、 核心思想

数位 DP 用于解决 “在区间 $[L, R]$ 内，有多少个整数满足性质 $X$” 的问题。

核心是将问题转化为 “一位一位填数字” 的过程，利用 记忆化搜索 (DFS + Memo) 复用重复状态。

$$\text{Ans} = \text{calc}(R) - \text{calc}(L-1)$$

---

## 二、 万能通用模版 (Python)

这是最稳健的写法，涵盖了 `is_limit` (上界限制) 和 `is_num` (前导零处理)。

Python

```
from functools import cache

class Solution:
    def solve(self, n: int) -> int:
        s = str(n)
        m = len(s)

        # @cache 自动记忆化 (i, state, is_limit, is_num)
        # state: 根据题目变化的参数 (如 mask, remainder, left_sum, has_diff 等)
        @cache
        def dfs(i: int, state: int, is_limit: bool, is_num: bool) -> int:
            # 1. 终止条件
            if i == m:
                # 通常：如果填过数字(is_num)则算1个，否则算0个
                # 有些题目这里需要检查 state 是否达标 (如 remainder == 0)
                return 1 if is_num else 0
            
            res = 0
            
            # 2. 处理前导零 (跳过当前位)
            if not is_num:
                # 保持 is_num=False，limit解除(因为位数变少了)
                res += dfs(i + 1, state, False, False)
            
            # 3. 确定填数范围
            # 这里的 start 取决于题目。
            # 大多数情况：如果还没填数字(not is_num)，这轮不能填0，只能从1开始(0的情况在上面跳过了)
            # 如果已经填过数字，可以从0开始。
            low = 1 if not is_num else 0
            up = int(s[i]) if is_limit else 9
            
            # 4. 枚举当前位数字
            for d in range(low, up + 1):
                # --- 业务逻辑 Check (剪枝) ---
                # 例如：if d == 4: continue (不能含4)
                # 例如：if (state >> d) & 1: continue (不能重复)
                
                # --- 状态转移 ---
                # new_state = update(state, d)
                res += dfs(i + 1, 
                           new_state, 
                           is_limit and d == up, 
                           True) # 只要进循环填了数，is_num 肯定变 True
            
            return res

        return dfs(0, 0, True, False)
```

---

## 三、 什么时候可以不写 `is_num`？

`is_num` 参数主要用于处理 **前导零 (Leading Zeros)**。如果不处理，`007` 会被当做 `7` 处理，且会把空串当做 `0`。

### 1. 必须写 `is_num` 的情况 (✅ Need)

当 **前导零的存在会干扰题目逻辑**，或者 **数字的长度敏感** 时。

|**场景**|**原因**|**代表题目**|
|---|---|---|
|**统计数字个数**|需要区分“跳过不填”和“填了0”。如果不写，空状态可能被算作0返回1。|**902. 最大为 N 的数字组合** (位数不同是不同方案)|
|**数字不能重复**|`00` 是前导零，不重复；`0` 是数字，可能重复。必须区分。|**2376. 统计特殊整数**|
|**特殊数字限制**|题目限定只能用 `{1,3,5}` 填空。如果不处理前导零，系统会默认填 `0` 补位，违背题意。|**3747. 移除零后的整数** (本质是不含0的数)|
|**旋转数字**|`0` 旋转是 `0` (有效)，但空串旋转无效。虽然这题可以混过去，但加上更稳。|**788. 旋转数字**|

### 2. 可以不写 `is_num` 的情况 (❌ No Need)

当 **前导零 `0` 对状态的影响与普通数字 `0` 一样**，且我们不关心数字的“长度”时。

|**场景**|**原因**|**代表题目**|
|---|---|---|
|**数位之和 (Digit Sum)**|`007` 的数位和是 7，`7` 的数位和也是 7。前导零加进去不改变和。|**1399, 1742** (统计数位和分组)|
|**整除/取模类**|`007 % k` 和 `7 % k` 是一样的。前导零对余数没有额外影响。|**2719. 统计整数数目** (虽有长度限制，但主要卡 range)|
|**包含数字 x**|只要不统计 0 的个数，前导零对“是否包含 4”没有影响。|统计不含 4 的数字|

---

## 四、 高阶技巧总结 (针对你练习的题目)

### 1. 数位和分组 (1399, 1742, 2719)

这几道题如果不让暴力，核心就是 **Target Sum**。

- **技巧**：状态定义为 `dfs(i, left)` 而不是 `dfs(i, current_sum)`。
    
- **优势**：`left` (剩余需要的和) 具有极强的**无后效性**，不同 `target` 循环之间可以复用缓存，从 $O(N \times Target)$ 优化到 $O(Target)$。
    
- **1399/1742 怎么做非暴力？**
    
    - 不用枚举 $1 \dots N$。
        
    - 直接枚举可能的数位和 $S$ (比如 1 到 162)。
        
    - 对每个 $S$，跑一遍 `dfs(0, S, True)` 算出有多少个数字符合该和。
        
    - 取最大值。
        

### 2. 有限集合填数 (902, 3747)

- **技巧**：`for d in range(low, up+1)` 改为 `for d in candidates`。
    
- **注意**：这种题目通常对位数敏感，必须用 `is_num` 处理前导零带来的“位数跳过”。
    
    - `3747` 题意转化为：在 $1 \sim N$ 中统计只包含 `1-9` 的数字个数。
        

### 3. 旋转数字/特殊规则 (788)

- **技巧**：状态中增加布尔变量。
    
- **State**：`has_diff` (是否已经包含了 2/5/6/9)。
    
- **转移**：`dfs(i+1, has_diff or (d in {2,5,6,9}), ...)`
    
- **陷阱**：搞清楚哪些是“无效数字”(3,4,7)，直接 `continue` 跳过；哪些是“不变数字”(0,1,8)，不改变 `has_diff` 状态。
    

### 4. 状态压缩 Mask (2376)

- **场景**：数字互不相同。
    
- **技巧**：用一个整数 `mask` 代替集合。`(mask >> d) & 1` 检查 d 是否用过，`mask | (1 << d)` 标记 d 已用。
    
- **复杂度**：$2^{10} \times 10$，非常小。
    

---

## 五、 练习题归类复习清单

|**题目 ID**|**题目名称**|**核心考点**|**关键状态/技巧**|
|---|---|---|---|
|**2376**|统计特殊整数|标准模版 + Mask|`dfs(i, mask, is_limit, is_num)`|
|**902**|最大为 N 的数字组合|有限集合 + 位数|枚举 `d in digits`，必须 `is_num`|
|**788**|旋转数字|特定规则 Bool 状态|`dfs(i, has_diff, ...)`，过滤 3,4,7|
|**1742**|盒子中小球最大数量|数位和 (Target Sum)|枚举 Sum, `dfs(i, left)` 复用 Cache|
|**1399**|统计最大组的数目|数位和 (Target Sum)|同上，注意 $N$ 较小，暴力也可，DP通用|
|**2719**|统计整数数目|范围和 + 大数取模|字符串处理大数，`left` 控制和范围|
|**3747**|移除零后不同整数|脑筋急转弯 -> DP|转化为：统计 $1 \sim N$ 中不含 0 的数|

### 🚀 总结语

你现在已经掌握了 is_limit 的精髓，也理解了副作用的危害。

接下来的进阶之路：

1. 熟练判断是否需要 `is_num` (如果不确定，**写上永远是保险的**)。
    
2. 熟练使用 `left` (剩余量) 这种“面向未来”的状态定义来优化 Cache。
    
3. 遇到“最大”、“第 K 小”等问题时，联想 **二分答案 + 数位 DP Check**。