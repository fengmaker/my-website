这份题目列表非常经典，涵盖了 **“两个字符串/数组（二维DP）”** 问题的核心考点。这一类问题通常被称为 **LCS（Longest Common Subsequence）家族** 问题。

我将按照你的要求，从**题目归类与状态定义**、**初始化的思考逻辑**、**空间优化推导**以及**通用代码模版**这几个维度进行深度的算法笔记总结。

---

### 一、 题目归类与核心逻辑

虽然题目不同，但它们的状态定义几乎完全一致。

核心状态定义 $dp[i][j]$：通常表示 text1 的前 $i$ 个字符（text1[0...i-1]）和 text2 的前 $j$ 个字符（text2[0...j-1]）在该问题下的最优解（最长长度、最小操作数、最大点积等）。

#### 1. 基础 LCS 模型

- **题目**：**1143. 最长公共子序列**、**1035. 不相交的线**
    
- **本质**：1035 只是把字符换成了数字，连线不能相交本质上就是求相对顺序不变的公共子序列。
    
- **转移方程**：
    
    - 若 $s1[i-1] == s2[j-1]$：$dp[i][j] = dp[i-1][j-1] + 1$
        
    - 若 $s1[i-1] \neq s2[j-1]$：$dp[i][j] = \max(dp[i-1][j], dp[i][j-1])$ （继承左边或上边的最大值）
        

#### 2. 删除/修改成本模型

- **题目**：**583. 两个字符串的删除操作**、**712. 最小 ASCII 删除和**、**72. 编辑距离**
    
- **本质**：字符不匹配时，不再是简单的“继承”，而是要付出“代价”（删除、替换等）。
    
- **转移方程**（以72题编辑距离为例）：
    
    - 若 $s1[i-1] == s2[j-1]$：$dp[i][j] = dp[i-1][j-1]$ （无代价）
        
    - 若 $s1[i-1] \neq s2[j-1]$：
        
        $$dp[i][j] = \min \begin{cases} dp[i-1][j] + 1 & \text{(删除 s1[i])} \\ dp[i][j-1] + 1 & \text{(s1 插入/s2 删除)} \\ dp[i-1][j-1] + 1 & \text{(替换)} \end{cases}$$
        

#### 3. 约束性选择模型

- **题目**：**1458. 两个子序列的最大点积**
    
- **本质**：类似 LCS，但“不选”不仅仅是跳过，可能因为负数导致结果变小。且题目要求子序列非空。
    
- **差异**：需要考虑 $nums1[i-1] \times nums2[j-1]$ 单独成为起点的可能性（抛弃之前的累积）。
    

---

### 二、 什么时候需要对数组进行“额外初始化”？

这是一个非常关键的问题。很多同学写 DP 容易在边界条件出错。

**判别法则：物理意义法**

思考 $dp[i][0]$ 和 $dp[0][j]$ 代表什么物理意义？

- $i=0$ 代表 `text1` 是空串。
    
- $j=0$ 代表 `text2` 是空串。
    

**1. 不需要特殊值初始化（默认为 0 即可）的情况**

- **LCS (1143, 1035)**：如果一个字符串是空的，最长公共子序列长度显然是 **0**。
    
    - $dp[i][0] = 0$, $dp[0][j] = 0$。
        
    - Java/C++ 默认 `int` 数组就是 0，所以不需要额外代码。
        

**2. 需要特殊初始化的情况**

- **编辑距离 (72)**：
    
    - 如果 `text1` 有 $i$ 个字符，`text2` 是空串。要变成空串，必须进行 $i$ 次删除操作。
        
    - **初始化**：$dp[i][0] = i$。
        
    - 同理：$dp[0][j] = j$。
        
- **删除操作 (583)**：
    
    - 同理，变成空串需要删除所有字符。
        
    - **初始化**：$dp[i][0] = i$, $dp[0][j] = j$。
        
- **ASCII 删除和 (712)**：
    
    - 变成空串需要删除所有字符，代价是字符 ASCII 码之和。
        
    - **初始化**：$dp[i][0]$ 应该是 `text1` 前 $i$ 个字符的 ASCII 累加和。
        
- **最大点积 (1458)**：
    
    - 由于可能存在负数，且要求**非空**。如果初始值全为 0，可能会覆盖掉真实的负数答案。
        
    - **初始化**：应该初始化为极小值（如 `-inf`）。但由于这题状态转移通常包含 `max` 逻辑，通常在循环内部处理 `dp[0][...]` 的逻辑或者利用 `padding` 的第一行第一列设为极小值。
        

---

### 三、 空间优化代码如何思考？（2D $\to$ 1D）

所有的 LCS 类问题，状态转移 $dp[i][j]$ 通常只依赖于三个位置：

1. $dp[i-1][j]$ （正上方，对应滚动数组的 `dp[j]`，即**本轮还没更新时的旧值**）
    
2. $dp[i][j-1]$ （正左方，对应滚动数组的 `dp[j-1]`，即**本轮已经更新过的新值**）
    
3. $dp[i-1][j-1]$ （左上方，**这是难点**）
    

#### 难点突破

当你把 `dp[i][j]` 压缩成 `dp[j]` 时：

- 在计算 `dp[j]` (新行) 时，数组里的 `dp[j]` 存的是上一行的值（相当于 $dp[i-1][j]$），这很好。
    
- 数组里的 `dp[j-1]` 已经被更新为当前行的值了（相当于 $dp[i][j-1]$），这也很好。
    
- **问题是**：你需要 $dp[i-1][j-1]$（上一行的左边）。但是因为 `dp[j-1]` 刚刚被更新了，**“左上角”的旧值丢失了**。
    

#### 解决方案

使用一个临时变量 `prev` (或者叫 `temp`, `backup`) 来专门记录**被覆盖之前的** `dp[j]`（即下一轮循环需要的“左上角”）。

**通用空间优化模版（以 LCS 为例）：**

Python

```
# 原始 2D: dp[i][j]
# 优化 1D: dp[j]

n, m = len(text1), len(text2)
dp = [0] * (m + 1)

for i in range(1, n + 1):
    prev = 0 # 代表 dp[i-1][0]，对应左上角初始值
    for j in range(1, m + 1):
        temp = dp[j] # 在 dp[j] 被更新前，先记下来，它将成为下一次内层循环的 "prev" (左上角)
        
        if text1[i-1] == text2[j-1]:
            # dp[i][j] = dp[i-1][j-1] + 1
            dp[j] = prev + 1 
        else:
            # dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            # dp[j] (未更新，即上方) vs dp[j-1] (已更新，即左方)
            dp[j] = max(dp[j], dp[j-1])
            
        prev = temp # 更新 prev，为下个 j 做准备
```

---

### 四、 基础代码模版

掌握这两种形式，面试和比赛通杀。

#### 1. 记忆化搜索 (Top-Down)

最符合人类直觉，适合处理边界复杂或不需要遍历所有状态的问题。

特点：使用 @cache 或手写 memo。

Python

```
# 以 72. 编辑距离 为例
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        import functools
        
        @functools.cache
        def dfs(i, j):
            # 1. Base Case (对应初始化逻辑)
            if i < 0: return j + 1 # word1 耗尽，word2 剩 j+1 个字符，需全部插入
            if j < 0: return i + 1 # word2 耗尽，word1 剩 i+1 个字符，需全部删除
            
            # 2. Transition
            if word1[i] == word2[j]:
                return dfs(i - 1, j - 1)
            else:
                return min(
                    dfs(i - 1, j),    # 删除
                    dfs(i, j - 1),    # 插入
                    dfs(i - 1, j - 1) # 替换
                ) + 1
                
        return dfs(len(word1) - 1, len(word2) - 1)
```

#### 2. 数组递推 (Bottom-Up)

工业级写法，易于进行空间优化，无递归栈溢出风险。

特点：1-indexed 技巧（在字符串前加空格或 DP 数组多开一行），避免处理 -1 索引。

Python

```
# 以 1143. 最长公共子序列 为例
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n, m = len(text1), len(text2)
        # DP table 多开一行一列，自动处理了 base case (全是0)
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # 注意字符串索引要 -1，因为 dp 是 1-based
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                    
        return dp[n][m]
```

#### 3. 数组递推 + 空间优化 (终极版)

以 **712. 两个字符串的最小 ASCII 删除和** 为例（涉及特殊初始化 + 空间优化）。

Python

```
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        dp = [0] * (n + 1)
        
        # 1. 第一行初始化 (当 s1 为空时，s2 需要删除的代价)
        for j in range(1, n + 1):
            dp[j] = dp[j-1] + ord(s2[j-1])
            
        for i in range(1, m + 1):
            prev = dp[0] # 保存左上角的值
            
            # 2. 第一列初始化 (当 s2 为空时，s1 需要删除的代价)
            # 当前 dp[0] 需要更新为 s1 前 i 个字符的 ASCII 和
            dp[0] += ord(s1[i-1]) 
            
            for j in range(1, n + 1):
                temp = dp[j] # 暂存，作为下一轮的左上角
                
                if s1[i-1] == s2[j-1]:
                    dp[j] = prev # 字符相同，不需要删除，继承左上角代价
                else:
                    # min(删除s1, 删除s2)
                    # dp[j] (旧值) 对应 dp[i-1][j] -> 删除 s1[i]
                    # dp[j-1] (新值) 对应 dp[i][j-1] -> 删除 s2[j]
                    dp[j] = min(dp[j] + ord(s1[i-1]), dp[j-1] + ord(s2[j-1]))
                
                prev = temp # 滚动 prev
                
        return dp[n]
```

### 总结建议

1. **初学/面试**：优先写 **二维数组递推**，最不容易出错，逻辑最清晰。
    
2. **写不出来时**：先写 **记忆化搜索 (DFS)**，逻辑直接照搬题目定义，通过了再改成递推。
    
3. **空间优化**：只有在题目明确卡空间或者作为 Follow-up 时才使用，关键在于用 `prev` 变量锁住左上角状态。