这份关于 **“最大子数组和” (Maximum Subarray Sum)** 系列问题的算法笔记总结。我们将从核心模型出发，通过你提供的题目，逐步拆解**状态定义的演变**和**解题思维的扩展**。

---

# 算法笔记：最大子数组和体系 (Kadane & Beyond)

## 1. 核心基石：LeetCode 53

这类问题的根本在于如何处理“连续性”。

### 方法一：动态规划 (Kadane 算法)

这是最通用的解法，空间复杂度可优化至 $O(1)$。

- **状态定义**：$dp[i]$ 表示 **以 $nums[i]$ 结尾** 的最大子数组和。
    
- 转移方程：
    
    $$dp[i] = \max(dp[i-1], 0) + nums[i]$$
    
    - _解读_：如果前面的累积是负数（累赘），就丢弃（置0），从当前开始；如果是正数（增益），就加上。
        
- **最终答案**：$\max(dp)$
    

### 方法二：前缀和 (Prefix Sum)

将子数组和问题转化为“买卖股票”问题。

- **原理**：子数组 $nums[j..i]$ 的和等于 $P[i] - P[j-1]$。
    
- **目标**：找到 $i$ 和 $j$ ($j \le i$) 使得 $P[i] - P[j-1]$ 最大。
    
- 策略：固定 $i$ (当前时刻卖出)，我们需要找到 $0$ 到 $i-1$ 之间最小的 $P[j-1]$ (历史最低点买入)。
    
    $$\text{Ans} = \max_i (P[i] - \min_{0 \le k < i} P[k])$$
    
- **应用场景**：当题目涉及**子数组长度限制**（如长度 $\le K$ 或 $\ge K$）时，Kadane 失效，必须用前缀和结合单调队列或滑动窗口求解。
    

---

## 2. 变体一：数值映射与绝对值 (Value Transformation)

这类题目本质还是 Kadane，只是 $nums[i]$ 的值需要预处理，或者目标函数变了。

### **2606. 找到最大开销的子字符串**

- **思路**：单纯的“换皮”题。
    
- **预处理**：构建一个 `mapping` 数组或哈希表，将字符串 $s$ 转化为数值数组 $vals$。
    
- **状态定义**：同核心基石。
    
- **技巧**：`cost = mapping.get(char, default_val)`。
    

### **1749. 任意子数组和的绝对值的最大值**

- **思路**：绝对值最大，要么是 **“最大的正数和”**，要么是 **“最小的负数和”**（绝对值变大）。
    
- **扩展**：同时跑两套 Kadane。
    
- **状态定义**：
    
    - $f_{max}[i]$：以 $i$ 结尾的最大子数组和。
        
    - $f_{min}[i]$：以 $i$ 结尾的最小子数组和。
        
- **答案**：$\max(\max(f_{max}), |\min(f_{min})|)$。实际上只需要维护前缀和的 `max_prefix - min_prefix` 也是等价的。
    

---

## 3. 变体二：拓扑结构变化 (Circular & Repeated)

这类题目改变了数组的物理形态（环形或重复拼接），核心技巧是 **“正难则反”** 和 **“分类讨论”**。

### **918. 环形子数组的最大和**

- **思路**：
    
    1. **情况 A (不成环)**：即标准 Kadane 最大和 `max_sum`。
        
    2. **情况 B (跨越边界)**：选中首尾，意味着中间某一段被“剔除”。要让首尾和最大，就是让中间这段的和最小。即 `TotalSum - min_sum`。
        
- **特例**：如果数组全是负数，`max_sum` 是最大单个元素，而 `TotalSum - min_sum` 会等于 0（因为 `min_sum` 会把所有数都选上），此时应返回 `max_sum`。
    
- **公式**：$\max(\text{max\_sum}, \text{TotalSum} - \text{min\_sum})$ （注意处理全负特例）。
    

### **1191. K 次串联后最大子数组之和**

- **思路**：
    
    - $k=1$：标准 Kadane。
        
    - $k \ge 2$：
        
        - 如果整个数组总和 `total > 0`：中间的 $k-2$ 个完整副本都可以吃满，只剩下“首部后缀”和“尾部前缀”要拼凑。这等价于在 **2 倍数组** (`arr * 2`) 上求最大子数组和，加上 $(k-2) \times total$。
            
        - 如果 `total <= 0`：中间的副本都是累赘，最大子数组一定不会跨越超过两个周期。等价于在 **2 倍数组** 上求最大子数组和。
            
- **总结**：在 `arr * 2` 上跑 Kadane 得到 `base_max`。如果 `total > 0`，结果是 `base_max + (k-2)*total`；否则是 `base_max`。
    

---

## 4. 变体三：差分与交换 (Difference & Gain)

### **2321. 拼接数组的最大分数**

- **题目**：只能交换一段子数组，让数组 1 或数组 2 的总和最大。
    
- **思路 (贡献法)**：
    
    - 假设我们要让数组 1 变大。交换区间 $[i, j]$ 意味着失去 $nums1[k]$，得到 $nums2[k]$。
        
    - 净收益 (Gain) = $\sum (nums2[k] - nums1[k])$。
        
    - 我们要让数组 1 的最终和最大，就是要在 $nums2 - nums1$ 这个差值数组中，找到一个**最大子数组和**。
        
- **算法**：
    
    1. 构造差值数组 `diff = [b - a for a, b in zip(nums1, nums2)]`。
        
    2. 对 `diff` 跑 Kadane 得到 `max_gain`。
        
    3. `Ans1 = sum(nums1) + max_gain`。
        
    4. 同理反向做一遍求 `Ans2`，取最大。
        

---

## 5. 思维扩展：乘积 (Product)

### **152. 乘积最大子数组**

- **核心区别**：加法只有“正增益”和“负累赘”，但乘法有 **“负负得正”**。一个极小的负数乘以一个负数可能瞬间变成最大值。
    
- 状态定义：
    
    需要同时维护两个状态，因为当前最小值可能翻身变最大值。
    
    - $f_{max}[i]$：以 $i$ 结尾的最大乘积。
        
    - $f_{min}[i]$：以 $i$ 结尾的最小乘积。
        
- 转移方程：
    
    由于 $nums[i]$ 可能是负数，最大值可能来自 f_min * nums[i]。
    
    $$f_{max}[i] = \max(nums[i], f_{max}[i-1] \times nums[i], f_{min}[i-1] \times nums[i])$$
    
    $$f_{min}[i] = \min(nums[i], f_{max}[i-1] \times nums[i], f_{min}[i-1] \times nums[i])$$
    

---

## 通用代码模版 (Python)

### 基础 Kadane (及变体)

Python

```
def solve_kadane(nums):
    ans = -float('inf')
    f = 0  # 当前以 i 结尾的最大和
    # f_min = 0  # 如果需要最小子数组和 (如 918, 1749)
    
    for x in nums:
        # 标准最大和
        f = max(f + x, x) # 等价于 max(f, 0) + x
        ans = max(ans, f)
        
        # 如果需要最小和 (配合环形或绝对值)
        # f_min = min(f_min + x, x)
        # min_ans = min(min_ans, f_min)
        
    return ans
```

### 乘积最大模版 (152)

Python

```
def maxProduct(nums):
    curr_max = curr_min = ans = nums[0]
    for x in nums[1:]:
        # 因为 x 可能是负数，先保存临时的 max
        # 注意：这里实际上是三个数比较：(x, curr_max*x, curr_min*x)
        # 包含了"另起炉灶" (x) 和 "延续" (*x)
        candidates = (x, curr_max * x, curr_min * x)
        curr_max = max(candidates)
        curr_min = min(candidates)
        ans = max(ans, curr_max)
    return ans
```

### 学习建议

1. **区分“子数组”与“子序列”**：如果题目允许跳过元素，那是**背包问题**或简单的正数求和，不要用 Kadane。
    
2. **看到“环形”**：立刻联想 `Total - MinSubarray`。
    
3. **看到“交换/修改子数组”**：立刻联想 **差值数组 (Diff Array)** 的最大子数组和。
    
4. **看到“长度限制”**：Kadane 失效，立刻转用 **前缀和 + 单调队列**。
    

接下来你可以尝试做一下 **Maximum Sum Circular Subarray** 的各种边界测试，或者挑战一下结合了树形 DP 的最大路径和问题。

这份笔记将深入探讨 **“子序列与背包的联系”**，并系统性地解决你提出的 **5 个思考题** 以及 **删除元素/上界限制的 4 个变形题**。

---

# 第一部分：为什么子序列是背包问题？

### 核心概念辨析

- **子数组 (Subarray)**：它是**刚性**的。就像推多米诺骨牌，选了 $i$ 和 $i+k$，中间的所有牌必须倒下。所以它的 DP 往往只依赖于 $dp[i-1]$（紧邻的前一个状态）。
    
- **子序列 (Subsequence)**：它是**柔性**的。你可以从数组这个“仓库”里挑挑拣拣，选出任意物品放入你的“集合”。
    
    - 如果你把数组中的每个数字看作一个**物品 (Item)**。
        
    - 把数字的值看作**价值 (Value)** 和 **重量 (Weight)**。
        
    - 这就完全转化为了 **背包问题 (Knapsack Problem)**。
        

### 场景映射

1. **最大子序列和**：
    
    - **背包视角**：容量无限，物品价值为 $nums[i]$，重量为 0。策略是“只要价值 $>0$ 就装进去”。
        
    - 这对应了最简单的贪心：$\sum_{x \in nums, x>0} x$。
        
2. **子序列和等于 Target (Subset Sum)**：
    
    - **背包视角**：**0/1 背包问题**。容量为 Target，物品重量为 $nums[i]$，求能否填满。
        
3. **最长递增子序列 (LIS)**：
    
    - 这是加了“顺序约束”的背包变体。物品不仅有价值，还有“序号”，且放入背包的物品序号必须单调递增。
        

---

# 第二部分：思考题解答 (代码与逻辑)

这里是针对你提出的 5 个基础变形题的 Python 实现和逻辑精讲。

### 1. 求最小子数组和

**逻辑**：Kadane 算法的反向运用。如果前缀累积是正的（会导致结果变大），就丢弃；如果是负的（会让结果更小），就保留。

Python

```
def minSubArray(nums: List[int]) -> int:
    ans = float('inf')
    f = 0
    for x in nums:
        # 核心修改：如果是正数累赘，归零；否则累加
        f = min(f, 0) + x
        ans = min(ans, f)
    return ans
```

### 2. 返回和最大的子数组 (Return Subarray)

**逻辑**：记录起止点。每当 `f` 被重置（另起炉灶）时更新 `start`；每当更新 `ans` 时记录 `best_range`。

Python

```
def maxSubArrayResult(nums: List[int]) -> List[int]:
    ans = -float('inf')
    f = 0
    start = 0
    best_range = (0, 0) # [start, end]
    
    for i, x in enumerate(nums):
        if f > 0:
            f += x
        else:
            f = x
            start = i # 另起炉灶，记录新起点
            
        if f > ans:
            ans = f
            best_range = (start, i)
            
    return nums[best_range[0] : best_range[1] + 1]
```

### 3. 子数组长度有下界 (Length $\ge k$)

逻辑：Kadane 失效（因为它是贪心，没法管长度）。转用 前缀和 + 维护历史最小值。

公式：$\max(P[i] - P[j])$，其中 $i - j \ge k \Rightarrow j \le i - k$。

我们需要在 $0 \dots i-k$ 的范围内找最小的 $P[j]$。

Python

```
def maxSubArrayLenLower(nums: List[int], k: int) -> int:
    n = len(nums)
    if n < k: return -1
    P = [0] * (n + 1)
    for i in range(n): P[i+1] = P[i] + nums[i]
        
    ans = -float('inf')
    min_pre = float('inf')
    
    # i 从 k 开始枚举 (代表子数组长度至少为 k)
    # 子数组是 nums[j...i-1], 和为 P[i] - P[j]
    for i in range(k, n + 1):
        # 能够减去的 P[j] 的位置是 i - k
        min_pre = min(min_pre, P[i - k])
        ans = max(ans, P[i] - min_pre)
    return ans
```

### 4. 子数组长度有上界 (Length $\le k$)

逻辑：前缀和 + 单调队列 (Monotonic Queue)。

公式：$\max(P[i] - P[j])$，其中 $i - j \le k \Rightarrow i - k \le j < i$。

这是一个“滑动窗口最小值”问题，用双端队列维护 $P$ 值的单调递增序列。

Python

```
from collections import deque
def maxSubArrayLenUpper(nums: List[int], k: int) -> int:
    n = len(nums)
    P = [0] * (n + 1)
    for i in range(n): P[i+1] = P[i] + nums[i]
        
    ans = -float('inf')
    q = deque([0]) # 存下标
    
    for i in range(1, n + 1):
        # 1. 队头过期 (离 i 太远)
        if q[0] < i - k:
            q.popleft()
        
        # 2. 计算当前最大子段和 (P[i] - 最小的P[j])
        ans = max(ans, P[i] - P[q[0]])
        
        # 3. 维护单调递增队列 (入队 P[i])
        while q and P[q[-1]] >= P[i]:
            q.pop()
        q.append(i)
    return ans
```

### 5. 子数组长度必须是奇数

逻辑：奇偶性前缀和。

长度 = $i - j$。若长度为奇数，则 $i$ 和 $j$ 的奇偶性必须不同。

- 如果当前 $i$ 是奇数，我们要减去最小的**偶数索引**前缀和。
    
- 如果当前 $i$ 是偶数，我们要减去最小的**奇数索引**前缀和。
    

Python

```
def maxSubArrayOddLen(nums: List[int]) -> int:
    P = 0
    ans = -float('inf')
    min_even = 0          # P[0]=0, 0是偶数
    min_odd = float('inf') 
    
    for i, x in enumerate(nums):
        P += x
        curr_idx = i + 1  # 前缀和数组的下标是 1...n
        
        if curr_idx % 2 != 0: # 当前是奇数下标
            ans = max(ans, P - min_even)
            min_odd = min(min_odd, P)
        else: # 当前是偶数下标
            ans = max(ans, P - min_odd)
            min_even = min(min_even, P)
    return ans
```

---

# 第三部分：扩展变形题 (删除与限制)

### 1. 子数组的元素和有上界 (Sum $\le Limit$)

问题：求子数组和最大，但不能超过 $K$。

难点：不能用 Kadane，也不具有单调性（不能用双指针），只能用 $O(N \log N)$ 的方法。

思路：前缀和 + 二分查找 (Sorted List)。

我们要找 $P[i] - P[j] \le K \Rightarrow P[j] \ge P[i] - K$。

即在 $i$ 之前，找一个大于等于 $P[i]-K$ 的最小 $P[j]$。

Python

```
import bisect
def maxSubArraySumLimit(nums: List[int], limit: int) -> int:
    from sortedcontainers import SortedList # 需要外部库或手写平衡树，笔试可用简单二分代替
    # 这里用二分模拟思路
    P = 0
    sorted_p = [0] # 维护有序的前缀和列表
    ans = -float('inf')
    
    for x in nums:
        P += x
        # 我们想找 P[j] >= P - limit
        target = P - limit
        idx = bisect.bisect_left(sorted_p, target)
        
        if idx < len(sorted_p):
            # 找到了合法的 P[j]，计算当前和
            ans = max(ans, P - sorted_p[idx])
        
        # 将当前 P 插入有序列表
        bisect.insort(sorted_p, P)
        
    return ans
```

### 2. 删除至多 k 次 (扩展 LeetCode 1186)

问题：允许从子数组中删除至多 $k$ 个元素（本质是跳过 $k$ 个负数），求最大和。

状态定义：

$dp[i][j]$：以 $nums[i]$ 结尾（必须包含 $nums[i]$）的子数组，且已经删除了 $j$ 次的最大和。

注意：这里的“删除”在逻辑上是“连接”，即 $nums[i]$ 拼到了 $nums[i-2]$ 后面（如果删了 $i-1$）。

更优的空间优化思路 ($O(N \cdot K)$)：

维护 $K+1$ 个变量。curr[j] 表示到达当前数字时，使用了 $j$ 次删除权力的最大和。

Python

```
def maxSubArrayDeleteK(nums: List[int], k: int) -> int:
    # dp[j] 表示: 以当前元素结尾，使用了 j 次删除机会的最大子段和
    # 初始化: 
    # dp[0] 是标准的 Kadane
    # dp[j] (j>0) 可以从"删除了当前元素"转移而来，也可以从"保留当前元素"转移而来
    
    # 稍微修正定义以便好写代码：
    # state[j] 表示使用了 j 次删除机会的最大和（必须以当前非删除元素结尾）
    
    n = len(nums)
    if n == 0: return 0
    
    # dp[j] 存储的是上一轮的状态
    # 初始全为 -inf，除了 dp[0] 初始化 logic
    dp = [-float('inf')] * (k + 1)
    dp[0] = -float('inf') # 初始状态修正，第一轮循环处理
    ans = -float('inf')
    
    # 辅助：处理全负数情况，如果允许返回空则 ans=0，否则 ans=max(nums)
    
    for x in nums:
        # 必须倒序更新，或者用临时数组，避免同一轮复用
        new_dp = list(dp)
        
        # 1. 不删除 (j=0): 标准 Kadane
        # new_dp[0] = max(dp[0] + x, x)
        # 注意 dp[0] 初始是 -inf, 第一次遇到 x 会变成 x
        if dp[0] > 0:
            new_dp[0] = dp[0] + x
        else:
            new_dp[0] = x
            
        # 2. 删除 1 到 k 次
        for j in range(1, k + 1):
            # 两种选择：
            # A. 保留 x: 接在上一轮使用了 j 次删除的子数组后面
            #    即 dp[j] + x (如果不另起炉灶) -> max(dp[j]+x, x)? 
            #    其实 x 可以另起炉灶，视为使用了 0 次删除。但这里我们在 j循环里，
            #    通常另起炉灶意味着 j=0。所以这里只能是 extend。
            keep_x = dp[j] + x
            
            # B. 删除 x: 接在上一轮使用了 j-1 次删除的子数组后面
            #    但是"删除 x" 意味着我们并没有"以 x 结尾"。
            #    这里有一个概念陷阱。
            #    正确的 DP 定义应该是：
            #    f[j] = 以当前位置(真实物理位置)结尾，删了 j 个数的最大和？不。
            #    应该是：当前指针走到 x，积累了 j 次删除操作的最大和。
            #    如果删了 x，那么最大和其实还是上一轮的值 (dp[j-1])，但逻辑位置移到了这里。
            
            # 修正 DP 方程 (LeetCode 1186 泛化):
            # held[j]: 到达当前位置，且保留了当前位置数字，共删了 j 次
            # skip[j]: 到达当前位置，且删除了当前位置数字，共删了 j 次 (实际值等于 held[j-1] of prev round)
            pass 
            
    # 重写简洁版 O(N*K) 逻辑
    # 维护 state[j]: 恰好删除了 j 次的最大子数组和 (结尾必须是保留的数字)
    # 对于每个 x，我们其实也可以选择"删除它"。
    # 如果删除 x，那么 state[j] 的值其实来自于 state[j-1] (上一轮的值)，并且和保持不变。
    
    # 我们用一个数组 dp[j] 表示：在当前流中，删除了 j 个元素后的最大连续和（当前元素可能被删，也可能被留）
    # 但为了保证连续性，如果删了当前元素，必须保证之前是连续的。
    
    dp = [-float('inf')] * (k + 1)
    # base case
    dp[0] = 0 # 类似 Kadane 的 f
    overall_max = -float('inf')
    
    for x in nums:
        # 倒序更新
        for j in range(k, 0, -1):
            # 选项 1: 保留 x。接在旧的 dp[j] 后面。
            # 选项 2: 删除 x。接在旧的 dp[j-1] 后面 (值不变，但消耗一次 j)。
            
            # 这里的难点是 Kadane 的 "x 另起炉灶"。
            # 另起炉灶意味着 j 归零。只有 j=0 的时候才允许 max(..., x)。
            # j > 0 时，必须连接前面的。
            
            take = max(dp[j] + x, -float('inf')) 
            delete = dp[j-1] # 删掉 x，和不变，次数+1
            
            dp[j] = max(take, delete)
        
        # 处理 j=0 的情况 (标准 Kadane)
        dp[0] = max(dp[0] + x, x)
        
        # 更新全局最大值
        overall_max = max(overall_max, max(dp))
        
    return overall_max
```

### 3. 改成恰好/至少删除 k 次

- **至多 k 次**：答案是 `max(dp[0]...dp[k])`。
    
- **恰好 k 次**：答案是 `dp[k]`。
    
- **至少 k 次**：答案是 `max(dp[k]...dp[limit])`（如果题目允许删除更多）。但通常这种题会变成“长度至少为 length - k 的子数组和”。
    

### 总结

打家劫舍系列和最大子数组系列是动态规划的两个基石。

- **打家劫舍**：核心是**选与不选的互斥**（相邻不能选）。
    
- **最大子数组**：核心是**连续性的维持**（如果断开就重置）。
    
- **结合体**：当子数组引入“删除”操作时，它就在局部引入了“跳过”的属性，变得更像背包问题了。