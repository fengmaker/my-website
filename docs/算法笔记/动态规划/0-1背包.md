这份 **0-1 背包问题全形态算法笔记** 涵盖了从最基础的“至多”到进阶的“恰好”、“至少”，以及不同目标（最大/最小/方案数）的完整理论体系。我们将遵循 **记忆化搜索 $\to$ 递推 DP $\to$ 空间优化** 的路径进行讲解。

---

# 第一部分：0-1 背包核心理论

**定义**：有 $N$ 个物品，第 $i$ 个物品重量为 $w[i]$，价值为 $v[i]$。有一个容量为 $W$ 的背包。每个物品只能选 **0次** 或 **1次**。

### 1. 核心状态转移方程

令 `dp[i][j]` 表示：从前 $i$ 个物品中选，当前背包容量状态为 $j$ 时的目标值（最大价值/最小价值/方案数）。

- **不选第 $i$ 个物品**：`dp[i][j] = dp[i-1][j]`
    
- **选第 $i$ 个物品**：`dp[i][j] = dp[i-1][j - w[i]] + v[i]` (前提 $j \ge w[i]$)
    

### 2. 三种实现形态的演进

以最经典的 **“至多装 W，求最大价值”** 为例。

#### 形态一：记忆化搜索 (DFS + Memo)

最直观，利用递归树剪枝。

Python

```
@cache
def dfs(i, c):
    # i: 当前考虑第 i 个物品, c: 剩余容量
    if i < 0: 
        return 0
    
    # 不选
    res = dfs(i - 1, c)
    
    # 选 (前提是装得下)
    if c >= w[i]:
        res = max(res, dfs(i - 1, c - w[i]) + v[i])
        
    return res
```

#### 形态二：二维数组 DP (递推)

Python

```
# 初始化 dp[N+1][W+1] 全为 0
for i in range(1, N + 1):
    for j in range(W + 1):
        if j < w[i-1]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1])
```

#### 形态三：一维数组空间优化 (Rolling Array)

这是做题最常用的模板。

关键点：必须 倒序遍历 容量 $j$。

- **原因**：二维状态中 `dp[i][j]` 依赖的是 `dp[i-1][...]`（上一层的数据）。如果正序遍历，计算 `dp[j]` 时用到的 `dp[j - w]` 已经是第 $i$ 层更新过的数据了（相当于一个物品被选了多次，变成了完全背包）。倒序遍历保证了使用的数据来自“上一层”。
    

Python

```
# dp[j] 表示容量为 j 时的最大价值
dp = [0] * (W + 1)
for i in range(N):
    # 必须倒序！从 W 到 w[i]
    for j in range(W, w[i] - 1, -1):
        dp[j] = max(dp[j], dp[j - w[i]] + v[i])
```

---

# 第二部分：容量限制的三种变种

这是该笔记的重点。**“至多”、“恰好”、“至少”的区别主要体现在初始化的不同。**

## 1. 至多装 W (Capacity $\le$ W)

这是最常见的类型。背包没装满也没关系，只要价值最大。

- **初始化**：`dp` 数组全部初始化为 **0**。
    
    - 物理含义：容量为 $j$ 时，如果不装任何东西，价值为 0，这是合法的。
        
- **最终答案**：`dp[W]` (或者 `max(dp)`，但在非负价值下 `dp[W]` 即最大)。
    

## 2. 恰好装 W (Capacity $=$ W)

要求背包必须被填满，多一分少一分都不行。

- **初始化**：
    
    - **求最大价值**：`dp[0] = 0`，其余 `dp[1...W] = -inf`。
        
        - _解释_：只有容量为 0 时不装东西是合法的（价值0）。其他容量如果不装东西，是“非法状态”，用负无穷表示不可达。
            
    - **求最小价值**：`dp[0] = 0`，其余 `dp[1...W] = +inf`。
        
    - **求方案数**：`dp[0] = 1`，其余 `dp[1...W] = 0`。
        
        - _解释_：容量 0 只有 1 种方案（什么都不装）。
            
- **最终答案**：`dp[W]`。如果 `dp[W]` 仍为 `inf/-inf`，说明无解。
    

## 3. 至少装 W (Capacity $\ge$ W)

这类题目通常问“至少获得 W 价值/体积的最小成本”。

注意：这里的“容量”逻辑会有变化，如果当前容量超出了 W，依然算作满足条件。

- **状态定义**：`dp[j]` 表示至少装载体积 $j$ 的最小价值/成本。
    
- **状态转移的一点不同**：
    
    - 如果背包容量是 5，物品体积是 7。装进去后，实际体积是 7，但我们只关心它“至少是 5”。所以如果 $j - w[i] < 0$，我们将其视为状态 0（至少为0，即空背包）。
        
    - 方程：`dp[j] = min(dp[j], dp[max(0, j - w[i])] + v[i])`
        
- **初始化**：`dp[0] = 0`，其余 `dp[1...W] = +inf`（求最小成本）。
    
- **遍历顺序**：依然是倒序，但范围通常是 `range(W, -1, -1)`，因为哪怕 $j < w[i]$ 也要更新（映射到 `dp[0]`）。
    

---

# 第三部分：目标函数的三种变种

## 1. 求最大/最小价值 (Max/Min Value)

- **操作**：使用 `max()` 或 `min()`。
    
- **方程**：`dp[j] = max(dp[j], dp[j - w] + v)`
    

## 2. 求方案数 (Number of Ways)

- **操作**：使用加法 `+`。
    
- **方程**：`dp[j] = dp[j] + dp[j - w]`
    
    - 含义：填满容量 $j$ 的方案数 = 不选当前物品的方案数 + 选当前物品的方案数。
        

---

# 第四部分：一整套代码详解 (Cheat Sheet)

我们将所有变种浓缩在几个模板中。假设物品列表为 `items`，每个元素 `(weight, value)`。

### 场景一：容量“至多 W”

Python

```
def knapsack_at_most(items, W):
    # 1. 求最大价值
    dp_val = [0] * (W + 1)
    # 2. 求装入方案数 (注意：这里通常指"装入物品总体积不超过W的方案数")
    # 如果指"恰好装至多W"(语病)，通常是 sum(dp_schemes)
    dp_ways = [1] + [0] * W 
    
    for w, v in items:
        for j in range(W, w - 1, -1):
            dp_val[j] = max(dp_val[j], dp_val[j - w] + v)
            dp_ways[j] += dp_ways[j - w] # 只要能装进去就算一种新方案
            
    return dp_val[W], sum(dp_ways)
```

### 场景二：容量“恰好 W”

这是最复杂的场景，包含三种目标。

Python

```
def knapsack_exactly(items, W):
    # 1. 求最大价值 (初始化为负无穷)
    dp_max = [-float('inf')] * (W + 1)
    dp_max[0] = 0
    
    # 2. 求最小价值 (初始化为正无穷) - 比如求凑满金额的最少硬币数(value是1)
    dp_min = [float('inf')] * (W + 1)
    dp_min[0] = 0
    
    # 3. 求方案数 (初始化 dp[0]=1)
    dp_count = [0] * (W + 1)
    dp_count[0] = 1
    
    for w, v in items:
        for j in range(W, w - 1, -1):
            # Max Value
            if dp_max[j - w] != -float('inf'): # 只有前置状态合法才转移
                dp_max[j] = max(dp_max[j], dp_max[j - w] + v)
            
            # Min Value
            if dp_min[j - w] != float('inf'):
                dp_min[j] = min(dp_min[j], dp_min[j - w] + v)
                
            # Count
            dp_count[j] += dp_count[j - w]
            
    # 结果处理
    max_res = dp_max[W] if dp_max[W] != -float('inf') else -1
    min_res = dp_min[W] if dp_min[W] != float('inf') else -1
    count_res = dp_count[W]
    
    return max_res, min_res, count_res
```

### 场景三：容量“至少 W” (求最小成本)

常用于：你需要至少 W 的营养/体积，每个物品有成本(value)，求最小成本。

Python

```
def knapsack_at_least(items, W):
    # dp[j] 表示至少获得体积 j 的最小成本
    dp = [float('inf')] * (W + 1)
    dp[0] = 0 # 至少获得 0 体积，成本为 0
    
    for w, cost in items:
        # 注意：这里也是倒序，但要遍历到 0
        # 为什么要遍历到 0？因为比如 W=5, w=7。dp[5] 可以从 dp[0] 转移过来
        # 状态 j 代表 "至少 j"，所以任何负的体积需求都映射回 dp[0]
        for j in range(W, -1, -1):
            prev_idx = max(0, j - w) # 关键技巧：不能小于0，小于0按0算
            dp[j] = min(dp[j], dp[prev_idx] + cost)
            
    return dp[W] if dp[W] != float('inf') else -1
```

---

# 第五部分：总结图表

|**限制类型**|**初始化 (求Max)**|**初始化 (求Min)**|**初始化 (求方案数)**|**状态转移特点**|
|---|---|---|---|---|
|**至多 W**|全 0|全 0|`dp[0]=1`, 余 0|正常 `dp[j-w]`|
|**恰好 W**|`dp[0]=0`, 余 `-inf`|`dp[0]=0`, 余 `+inf`|`dp[0]=1`, 余 0|依赖合法前驱|
|**至少 W**|N/A|`dp[0]=0`, 余 `+inf`|N/A  不适用|`dp[max(0, j-w)]`|

**记忆化搜索 vs 一维 DP 选择建议：**

1. **一维 DP**：是**最推荐**的写法。代码短，空间 $O(W)$，常数小。
    
2. **记忆化搜索**：适合状态转移非常复杂（比如有额外约束条件，不仅仅是重量），或者需要输出具体路径时使用。
    
3. **恰好/至少**：用 DP 写法时，初始化决定了一切。
    

**练习题目推荐：**

- **至多 + Max**：LeetCode 416. 分割等和子集 (变种)
    
- **恰好 + 方案数**：LeetCode 494. 目标和
    
- **恰好 + Min**：LeetCode 322. 零钱兑换 (完全背包，但逻辑类似)
    
- **至少 + Min**：Luogu P2196 (虽然是挖地雷，但有类似思想) 或者 这里的模板直接用。


这篇笔记将为你彻底梳理 **0-1 背包问题** 的基础，并重点解析 **位运算（Bitset）优化** 的适用边界。我们把题目分为“能用位运算”和“不能用位运算”两类，让你一眼看穿本质。

---

# 第一部分：0-1 背包基础复习 (Standard 0-1 Knapsack)

**核心定义**：$N$ 个物品，容量 $W$。每个物品只有 **“选”** 或 **“不选”** 两个状态。

### 1. 通用状态定义

`dp[j]`：当背包容量为 $j$ 时，能获得的 [最大价值 / 方案数 / 是否可达]。

### 2. 标准 1D 模板 (必背)

**必须倒序遍历**，防止一个物品被使用多次（防止变成完全背包）。

Python

```
# 初始化
# 求最大价值: dp = [0] * (target + 1)
# 求方案数: dp = [1] + [0] * target
# 求可行性: dp = [True] + [False] * target

for x in nums:  # 遍历物品
    for j in range(target, x - 1, -1):  # 倒序遍历容量
        # 1. 求最大价值 (Value)
        dp[j] = max(dp[j], dp[j - x] + value)
        
        # 2. 求方案数 (Count)
        dp[j] += dp[j - x]
        
        # 3. 求可行性 (Boolean)
        dp[j] = dp[j] or dp[j - x]
```

---

# 第二部分：位运算优化 (Bitset Optimization)

核心原理：

利用 CPU 的位并行能力（一次处理 64 位），将内层循环的时间复杂度除以 64（在 Python 中甚至是几千倍优化）。

### 1. 适用题目类型 (黄金法则)

只有满足以下条件的 0-1 背包才能用位运算直接优化：

1. **求可行性 (Reachability)**：问“能不能凑出和为 `target`”、“所有可能的和”。
    
2. **特殊的逻辑截取**：如 3180 题，限制条件是数值大小，而非具体的背包容量，且涉及布尔状态转移。
    

**注意**：

- **求“方案数”**：**不能**用简单的位运算优化（因为二进制位只能存 0/1，存不下方案数量）。
    
- **求“最大长度/最大价值”**：**不能**用简单的位运算优化（二进制位存不下 value 或 length）。
    

### 2. 位运算模板 (Python)

Python

```
f = 1  # 初始状态 {0} 可达
for x in nums:
    # f       : 不选 x
    # f << x  : 选 x (所有已达成的和加上 x)
    f |= (f << x) 
```

---

# 第三部分：题目归类与算法笔记

我们将你提供的题目根据**“是否可以用位运算优化”**进行分类详解。

### 第一类：位运算优化的主场 (可行性 / 特殊逻辑)

这一类题目的特点是：**状态只是 True/False**。

#### 1. [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

- **题意**：判断能否将数组分割成和相等的两部分。
    
- **转化**：这就是问“能不能从数组中选出一些数，凑出和为 `Sum / 2`”。
    
- **类型**：**标准可行性 0-1 背包**。
    
- **代码 (Bitset)**：
    
    Python
    
    ```
    class Solution:
        def canPartition(self, nums: List[int]) -> bool:
            total = sum(nums)
            if total % 2 != 0: return False
            target = total // 2
    
            f = 1
            for x in nums:
                f |= (f << x)
    
            return (f >> target) & 1 == 1
    ```
    

#### 2. [3180. 执行操作可获得的最大总奖励 I](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/) (及 II)

- **题意**：拿 x 必须满足 `当前总分 < x`。
    
- **类型**：**带特殊限制的可行性背包**。
    
- **为何能优化**：虽然求“最大”奖励，但状态 `f` 记录的是“某个总分是否可达”。最后返回 `f` 中最高位的 1 即可。
    
- **代码 (Bitset + Mask)**：
    
    Python
    
    ```
    class Solution:
        def maxTotalReward(self, rewardValues: List[int]) -> int:
            nums = sorted(list(set(rewardValues)))
            f = 1
            for x in nums:
                # 只有小于 x 的状态才能转移，所以用 mask 截取
                mask = (1 << x) - 1
                f |= (f & mask) << x
            return f.bit_length() - 1
    ```
    

---

### 第二类：标准一维 DP (方案数 / 最值)

这一类题目**不能**直接用 `f |= f << x`，因为我们需要记录具体的**数量**或**长度**，二进制位存不下。必须使用整数数组。

#### 3. [494. 目标和](https://leetcode.cn/problems/target-sum/)

- **题意**：添加 +/- 号凑出 target。
    
- **转化**：设正数集合和为 P，负数集合和为 N。$P - N = target$，且 $P + N = Sum$。$\implies 2P = Sum + target$。问题转化为：**填满容量为 P 的背包有多少种方案**。
    
- **类型**：**求方案数**。
    
- **状态**：`dp[j]` = 填满容量 `j` 的方案数。
    
- **代码 (标准数组)**：
    
    Python
    
    ```
    class Solution:
        def findTargetSumWays(self, nums: List[int], target: int) -> int:
            total = sum(nums)
            if (total + target) < 0 or (total + target) % 2 != 0:
                return 0
            bag_size = (total + target) // 2
    
            dp = [0] * (bag_size + 1)
            dp[0] = 1 # 容量0方案数为1
    
            for x in nums:
                for j in range(bag_size, x - 1, -1):
                    dp[j] += dp[j - x] # 累加方案
            return dp[bag_size]
    ```
    

#### 4. [2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/)

- **题意**：用 $1^x, 2^x, 3^x...$ 凑出 $n$ 的方案数。
    
- **转化**：物品是 $v = i^x$，背包容量是 $n$。
    
- **类型**：**求方案数**。
    
- **代码 (标准数组)**：
    
    Python
    
    ```
    class Solution:
        def numberOfWays(self, n: int, x: int) -> int:
            MOD = 10**9 + 7
            dp = [0] * (n + 1)
            dp[0] = 1
    
            # 物品是 1^x, 2^x... 直到超过 n
            num = 1
            while (val := num ** x) <= n:
                for j in range(n, val - 1, -1):
                    dp[j] = (dp[j] + dp[j - val]) % MOD
                num += 1
            return dp[n]
    ```
    

#### 5. [2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/)

- **题意**：凑出 target，要求用的元素最多（长度最长）。
    
- **转化**：0-1 背包，但价值是 1（每个物品贡献长度1），求最大价值。
    
- **类型**：**求最大价值 (Max Value)**。
    
- **初始化注意**：这是“恰好装满”类型，`dp[0]=0`，其余 `-inf`。
    
- **代码 (标准数组)**：
    
    Python
    
    ```
    class Solution:
        def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
            dp = [-float('inf')] * (target + 1)
            dp[0] = 0
    
            for x in nums:
                for j in range(target, x - 1, -1):
                    if dp[j - x] != -float('inf'): # 只有前置状态合法才转移
                        dp[j] = max(dp[j], dp[j - x] + 1)
    
            return dp[target] if dp[target] > 0 else -1
    ```
    

---

### 第四部分：终极总结表

做题时，看一眼题目问什么，直接选模板：

|**题目问法**|**核心类型**|**状态转移方程**|**能否位运算优化？**|**典型题目**|
|---|---|---|---|---|
|**能不能凑出...**|**可行性**|`dp[j] = dp[j] or dp[j-w]`|**能！(秒杀)**|416, 3180|
|**有多少种方法...**|**方案数**|`dp[j] += dp[j-w]`|**不能**|494, 2787|
|**最长/最大价值...**|**最值**|`dp[j] = max(dp[j], dp[j-w] + v)`|**不能**|2915|

心法：

看到“和为 K”、“能否分成两份”、“子集和” $\to$ 0-1 背包。

如果是问“是否存在/可行性” $\to$ 直接上 Python 的位运算。

如果是问“数量/最大” $\to$ 老老实实写数组 DP。