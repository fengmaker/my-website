

## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:

        ans = []

        s = set(to_delete)

        def dfs(root):

            if not root:

                return None

            root.left = dfs(root.left)

            root.right = dfs(root.right)

            if root.val in s:

                if root.left:

                    ans.append(root.left)

                if root.right:

                    ans.append(root.right)

                return None

            else:

                return root

        remaining = dfs(root)

        if remaining:

            ans.append(remaining)

        return ans
        

class Solution:

    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        if not root:

            return None

        root.left = self.pruneTree(root.left)

        root.right = self.pruneTree(root.right)

        if root.left is None and root.right is None and root.val == 0:

            return None

        return root
        

class Solution:

    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:

        if not root:

            return None

        root.left = self.removeLeafNodes(root.left,target)

        root.right = self.removeLeafNodes(root.right,target)

        if root.left is None and root.right is None and root.val == target:

            return None

        return root

```


# 算法笔记：二叉树的修剪与删除 (Post-order Traversal)

## 1. 核心思维：自底向上 (Bottom-Up)

此类题目（如删除特定值的叶子、剪除全0子树、删点成林）的核心在于：**父节点的命运取决于子节点处理后的状态**。

- **为什么必须是后序遍历（Post-order）？**
    
    - 这就好比修剪一棵真正的树，必须先去修剪末端的枝叶。
        
    - 如果先处理父节点（前序），此时子节点还没被修剪，父节点无法根据子节点“最新的状态”来判断自己是否变成了叶子节点。
        
    - **口诀**：先子后父，子亡父危。
        

## 2. 万能解题模版 (The Template)

这类题目代码结构高度统一，请背诵以下 **“递归三部曲”**：

Python

```
class Solution:
    def solveTree(self, root: Optional[TreeNode], ...) -> Optional[TreeNode]:
        
        def dfs(node):
            # 1. Base Case：空节点直接返回
            if not node:
                return None
            
            # 2. 核心操作：接收递归返回值（指针重连）
            # 必须重新赋值，这样才能切断与被删节点的联系
            node.left = dfs(node.left)
            node.right = dfs(node.right)
            
            # 3. 逻辑判断：决定当前节点的去留
            # 此时 node.left/right 已经是处理干净的状态
            if self.shouldDelete(node): 
                # 针对不同题目可能有额外操作（如 delNodes 需要收集子节点）
                return None  # 返回 None 代表当前节点被删
            
            return node      # 返回 node 代表当前节点保留
            
        return dfs(root)
```

## 3. 题目变体与细节对比

|**题目**|**LC 编号**|**核心判断逻辑 (shouldDelete)**|**特殊处理**|
|---|---|---|---|
|**删除给定值的叶子**|1325|`node.left is None`<br><br>  <br><br>`and node.right is None`<br><br>  <br><br>`and node.val == target`|无，标准模版。|
|**二叉树剪枝** (删全0子树)|814|`node.left is None`<br><br>  <br><br>`and node.right is None`<br><br>  <br><br>`and node.val == 0`|本质同上，只是 target 固定为 0。|
|**删点成林**|1110|`node.val in to_delete_set`|1. 若当前点要删，且有幸存子节点，需将子节点加入结果集 `ans`。<br><br>  <br><br>2. 需特判最外层的 `root` 是否幸存。|

## 4. 关键易错点 (Pitfalls)

### A. 指针重连 (Pointer Re-assignment)

- **错误写法**：只调用递归，不接收返回值。
    
    Python
    
    ```
    dfs(node.left)  # 错！node.left 依然指向原对象，即使原对象在递归里返回了 None
    ```
    
- **正确写法**：
    
    Python
    
    ```
    node.left = dfs(node.left) # 对！更新指针
    ```
    

### B. `delNodes` 的集合优化

- 题目给出的 `to_delete` 通常是列表 `List[int]`。
    
- **务必**在递归前将其转为哈希集合 `set(to_delete)`。
    
- 查找复杂度从 $O(N \times M)$ 降为 $O(N)$。
    

### C. `delNodes` 的根节点处理

- 递归函数 `dfs` 内部通常只处理“父节点死，子节点存”的情况。
    
- **原树的根节点**没有父节点，所以必须在主函数最后单独判断：
    
    Python
    
    ```
    remaining_root = dfs(root)
    if remaining_root:
        ans.append(remaining_root)
    ```
    

## 5. 思考流程 (Mental Model)

做题时，按以下步骤思考：

1. **遍历顺序**：涉及改动树结构、依赖子树状态 $\rightarrow$ **后序遍历**。
    
2. **递归函数定义**：`dfs(node)` 的返回值是什么？通常是**修改后的该子树的根节点**（`None` 或 `node`）。
    
3. **单层逻辑**：
    
    - 先把左右孩子“修剪”好。
        
    - 检查自己：
        
        - 如果是“剪叶子”题：看自己是不是变成了光杆司令（左右为 None）且符合值要求。
            
        - 如果是“删点”题：看自己是不是在黑名单里。
            
4. **善后**：如果是 `delNodes` 这种要返回森林的，记得检查最原始的 `root`。
    

---

> 一句话总结：
> 
> 遇树删点用后序，指针重连是关键；
> 
> 叶子判断看左右，删点托孤记心间。

