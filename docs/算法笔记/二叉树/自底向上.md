
# 算法笔记：二叉树递归的三大思维模型

## 🧠 核心心法：老板思维 (The Boss Mentality)

做递归题时，不要把自己当成正在递归的那个节点（深陷细节），要将自己视为当前子树的“老板”（父节点）。

你只需要指挥左右子节点（下属）去干活，并关心他们给你交回来什么结果。

---

## 模型一：构建/改造类 (Construction)

**典型题目**：`mergeTrees` (合并), `invertTree` (翻转), `connect` (填充指针)

### 1. 思考模型

- **父节点心态**：“左儿子、右儿子，你们去把各自的子树处理好（合并/翻转/修剪），然后**把处理完的头节点还给我**，我要用 `root.left = ...` 把你们接住。”
    
- **返回值类型**：`TreeNode` (节点本身)。
    

### 2. 思考过程 (Step-by-Step)

1. **我是谁？** 我是当前需要构建/修改的节点。
    
2. **我要给上级交什么？** 交回我自己（修改后的 `root`）。
    
3. **边界条件 (Base Case)**：
    
    - 如果我根本不存在 (`None`)，我应该返回什么？
        
    - 通常返回 `None`。
        
    - _特例_：如 `mergeTrees`，如果我空了但对方不空，返回对方。
        
4. **核心动作**：
    
    - 接住左边的结果：`root.left = dfs(root.left)`
        
    - 接住右边的结果：`root.right = dfs(root.right)`
        
    - 返回我自己：`return root`
        

### 3. 代码模版

Python

```
def dfs(root):
    # 边界：没东西可修了，返回空
    if not root: return None 
    
    # (可选) 此时可能需要处理 root.val 或交换左右子树
    
    # 核心：接住下属的返回
    root.left = dfs(root.left)   
    root.right = dfs(root.right) 
    
    return root # 任务完成，交差
```

---

## 模型二：计算/统计类 (Calculation)

**典型题目**：`maxDepth` (最大深度), `countNodes` (节点数), `maxPathSum` (最大路径和)

### 1. 思考模型

- **父节点心态**：“我不需要你们的节点指针，我只要你们算出**你们那边的数值**（深度/个数/路径和）。我拿到这两个数字，结合我自己的值，算出一个新数字汇报给上级。”
    
- **返回值类型**：`int` / `float` (数值)。
    

### 2. 思考过程 (Step-by-Step)

1. **我是谁？** 我是一个统计员。
    
2. **我要给上级交什么？** 一个数字。
    
3. **边界条件 (Base Case)**：
    
    - 如果我是 `None`，我对结果的贡献是多少？
        
    - 求和/求数 -> 返回 `0`。
        
    - 求最小 -> 返回 `inf` (避免干扰 `min` 计算)。
        
4. **核心动作**：
    
    - 收集左边数据：`left_stat = dfs(root.left)`
        
    - 收集右边数据：`right_stat = dfs(root.right)`
        
    - 加工数据：`return func(left_stat, right_stat) + self.val`
        

### 3. 代码模版

Python

```
def dfs(root):
    # 边界：空节点贡献为 0
    if not root: return 0 
    
    left_val = dfs(root.left)  
    right_val = dfs(root.right) 
    
    # 核心：数学加工 (例如找最大深度)
    return max(left_val, right_val) + 1 
```

---

## 模型三：搜索/判断类 (Search/Validation)

**典型题目**：`isUnivalTree` (单值树), `isValidBST` (验证BST), `lowestCommonAncestor` (最近公共祖先)

### 1. 思考模型

- **父节点心态**：“你们那边符合规定吗？或者找到了我要的人了吗？**只要有一个坏消息/好消息，立刻汇报！**”（短路逻辑 / 一票否决）。
    
- **返回值类型**：`bool` (True/False) 或 `TreeNode` (找到的特定目标)。
    

### 2. 思考过程 (Step-by-Step)

1. **我是谁？** 我是一个质检员或搜救员。
    
2. **我要给上级交什么？** 是/否 (`bool`) 或者 目标对象。
    
3. **边界条件 (Base Case)**：
    
    - 走到死胡同 (`None`) 了意味着什么？
        
    - 判断合法性 -> 通常返回 `True` (空树默认合法)。
        
    - 搜索目标 -> 通常返回 `None` (没找到)。
        
4. **核心动作**：
    
    - **Fail Fast (一票否决)**：如果我这里的局部检查失败，直接 `return False`。
        
    - **Short Circuit (短路)**：`return check(left) and check(right)`。
        

### 3. 代码模版

Python

```
def dfs(root):
    # 边界：空树通常是合法的/无害的
    if not root: return True 
    
    # 1. 局部检查：我自己是否违规？
    if root.val != target: return False
    
    # 2. 递归检查：左右子树是否也都合规？
    # 逻辑与 (AND)：全家都得对
    return dfs(root.left) and dfs(root.right)
    
    # 或者 逻辑或 (OR)：只要找到一个就行
    # return dfs(root.left) or dfs(root.right)
```

---

## 💡 总结：解题三问 (Methodology)

拿到二叉树递归题，先别动手，按顺序问自己三个问题：

|**步骤**|**问题**|**对应模型**|**边界思考 (If not root)**|
|---|---|---|---|
|**Step 1**|**父节点需要我返回什么？**|-|-|
||"要修好的节点"|**构建类**|返回 `None` / `root2`|
||"要统计数字"|**计算类**|返回 `0` / `inf`|
||"要True/False/目标"|**搜索类**|返回 `True` / `None`|
|**Step 2**|**如果我是空节点，对结果有何影响？**|(见上表)|决定 Base Case 写法|
|**Step 3**|**如果左右都有结果，我该怎么合并？**|赋值 / 数学运算 / 逻辑与或|决定核心逻辑写法|

## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:

        if not root:

            return True

        v = root.val  

        if root.left:

            if v != root.left.val or not self.isUnivalTree(root.left):

                return False

        if root.right:

            if v != root.right.val or not self.isUnivalTree(root.right):

                return False

        return True
        
        
        # Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:

        if not root:

            return True

        if root.left and root.left.val != root.val:

            return False

        if root.right and root.right.val != root.val:

            return False

        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 





## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:

        def isSameTree(p,q):

            if not p or not q:

                return p is q

            return p.val == q.val and isSameTree(p.left,q.right) and isSameTree(p.right,q.left)

        return isSameTree(root.left,root.right)
class Solution:

    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:

        if not p or not q:

            return p is q

        return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 对称二叉树和相同树的判断，经典。判断两个节点是否相同，先判断是否都为空，然后一个为空或者值不相等就不对



## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        if root1 is root2:

            return True

        if not root1 or not root2 or root1.val != root2.val:

            return False

        return (self.flipEquiv(root1.left,root2.left) and self.flipEquiv(root1.right,root2.right)) or (self.flipEquiv(root1.left,root2.right) and self.flipEquiv(root1.right,root2.left))

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 比如这题翻转二叉树 和上面思路一脉相承



## 核心代码

```python

class Solution:

    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:

        if not original:

            return None

        if original is target:

            return cloned

        return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 比较节点，让原树和克隆一起动，然后比较地址 用is



## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        def check(root):

            if not root:

                return 0

            l = check(root.left)

            if l == -1:

                return -1

            r = check(root.right)

            if r == -1:

                return -1

            if abs(l - r) > 1:

                return -1

            return max(l,r) + 1

        return check(root) != -1


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 平衡二叉树，需要自底向上，层层汇报，不能只判断根节点是否平衡，每一个都要



## 核心代码

```python


class Solution:

    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        if not root:

            return root

        return TreeNode(root.val,self.invertTree(root.right),self.invertTree(root.left))
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 翻转二叉树



## 核心代码

```python

class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None: return root2
        if root2 is None: return root1
        return TreeNode(root1.val + root2.val,
            self.mergeTrees(root1.left, root2.left),    # 合并左子树
            self.mergeTrees(root1.right, root2.right))  # 合并右子树
            
            
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None: return root2
        if root2 is None: return root1
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)     # 合并左子树
        root1.right = self.mergeTrees(root1.right, root2.right)  # 合并右子树
        return root1

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 有的时候可以不用创建新节点



## 核心代码

```python

class Solution:

    def evaluateTree(self, root: Optional[TreeNode]) -> bool:

        if root.val < 2:

            return root.val == 1

        if root.val == 2:

            return self.evaluateTree(root.left) or self.evaluateTree(root.right)

        else:

            return self.evaluateTree(root.left) and self.evaluateTree(root.right)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 判断完全二叉树，一定有根节点情况可以省略一些判断，不确定树的情况时，判断叶子结点，也有可能走到空的地方



## 核心代码

```python
class Solution:

    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:

        cnt = defaultdict(int)

        def dfs(node):

            if node is None:

                return 0

            sum = node.val + dfs(node.left) + dfs(node.right)

            cnt[sum] += 1

            return sum

        dfs(root)

        max_cnt = max(cnt.values())

        return [s for s,c in cnt.items() if c == max_cnt]


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 出现次数最多的子树元素和



## 核心代码

```python

class Solution:

    def findTilt(self, root: Optional[TreeNode]) -> int:

        ans = 0

        def dfs(root):

            if not root:

                return 0

            l = dfs(root.left)

            r = dfs(root.right)

            nonlocal ans

            ans += abs(l - r)

            return l + r + root.val

        dfs(root)

        return ans


class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        # 主函数只负责解包第二个返回值
        return self.dfs(root)[1]

    # 返回值：(子树和, 子树坡度总和)
    def dfs(self, node):
        if not node: return 0, 0
        
        l_sum, l_tilt = self.dfs(node.left)
        r_sum, r_tilt = self.dfs(node.right)
        
        # 当前节点的坡度
        current_tilt = abs(l_sum - r_sum)
        
        # 当前子树的总和
        current_sum = l_sum + r_sum + node.val
        
        # 总坡度 = 左边坡度 + 右边坡度 + 我自己的坡度
        total_tilt = l_tilt + r_tilt + current_tilt
        
        return current_sum, total_tilt
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 仔细读题，好好品味两个参数的返回值的dfs函数




## 核心代码

```python
class Solution:

    def averageOfSubtree(self, root: TreeNode) -> int:

        ans = 0

        def dfs(root):

            if not root:

                return 0,0

            l_s,l_n = dfs(root.left)

            r_s,r_n = dfs(root.right)

            s = l_s + r_s + root.val

            n = l_n + r_n + 1

            nonlocal ans

            avg = s // n

            if root.val == avg:

                ans += 1

            return s,n

        dfs(root)  

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这题很好，运用两个返回值维护状态，往上传




## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:

        hs = []

        def dfs(root):

            if not root:

                return 0

            l_h = dfs(root.left)

            r_h = dfs(root.right)

            if l_h < 0 or l_h != r_h:

                return -1

            hs.append(l_h + 1)

            return l_h + 1

        dfs(root)

        if len(hs) < k:

            return -1

        hs.sort()

        return (1 << hs[-k]) - 1


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 向上汇报可以传递下面的合法状态，否则就返回需要的值，这是一种技巧
















































