

## 核心代码

```python

class Solution:

    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        ans = False

        def dfs(root,num):

            if not root:

                return

            if root.val == num and root.left is None and root.right is None:

                nonlocal ans

                ans = True

                return  

            dfs(root.left,num - root.val)

            dfs(root.right,num - root.val)

        dfs(root,targetSum)

        return ans

class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        targetSum -= root.val
        if root.left is None and root.right is None:  # root 是叶子
            return targetSum == 0
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 路径总和，怎么写的优雅，对于这类判断真假的题目，通常可以直接复用原函数





## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def sumNumbers(self, root: Optional[TreeNode]) -> int:

        ans = 0

        def dfs(root,val):

            if not root:

                return

            val = 10 * val + root.val

            if root.left is None and root.right is None:

                nonlocal ans

                ans += val

                return

            dfs(root.left,val)

            dfs(root.right,val)

        dfs(root,0)

        return ans


class Solution:
    def sumNumbers(self, root: Optional[TreeNode], x=0) -> int:
        if root is None:
            return 0
        x = x * 10 + root.val
        if root.left is None and root.right is None:  # root 是叶子节点
            return x
        return self.sumNumbers(root.left, x) + self.sumNumbers(root.right, x)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 保存全局变量更新，和使用递归都行



## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:

        level = 0

        ans = []

        def dfs(root,cnt):

            if not root:

                return

            cnt += 1

            nonlocal level

            if cnt > level:

                level = cnt

                ans.append(root.val)

            dfs(root.right,cnt)

            dfs(root.left,cnt)

        dfs(root,0)

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 二叉树右视图



## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def goodNodes(self, root: Optional[TreeNode]) -> int:

        ans = 0

        def dfs(root,mx):

            if not root:

                return

            if root.val >= mx:

                nonlocal ans

                ans += 1

            dfs(root.left,max(mx,root.val))

            dfs(root.right,max(mx,root.val))

        dfs(root,root.val)

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 遇到题不要先向全局，先考虑原问题和子问题之间的关系是好习惯



## 核心代码

```python
# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

```python
def sumEvenGrandparent(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(root):
            if not root:
                return 
            nonlocal ans 
            if root.val % 2 == 0:
                if root.left:
                    if root.left.left:
                        ans += root.left.left.val 
                    if root.left.right:
                        ans += root.left.right.val 
                if root.right:
                    if root.right.left:
                        ans += root.right.left.val 
                    if root.right.right:
                        ans += root.right.right.val 
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return ans 
        
        
        class Solution:

    def sumEvenGrandparent(self, root: Optional[TreeNode]) -> int:

        ans = 0

        def dfs(gp_val,p_val,node):

            if not node:

                return

            if gp_val % 2 == 0:

                nonlocal ans

                ans += node.val

            dfs(p_val,node.val,node.left)

            dfs(p_val,node.val,node.right)

        dfs(1,1,root)

        return ans



```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 更多时候考虑当前节点看问题，需要上面状态设置参数传下来就行





## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:

        if not root:

            return

        cur_char = chr(ord("a") + root.val)

        if not root.left and not root.right:

            return cur_char

        l_s = self.smallestFromLeaf(root.left) if root.left else "~"

        r_s = self.smallestFromLeaf(root.right) if root.right else "~"

  

        return min(r_s,l_s) + cur_char

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
>  递就是先序遍历，遍历一个点更新在此点上情况，并维护全局的情况；
>  归就是后序遍历，根据左子树的情况和右子树的情况，得到本树的情况  
>   一个是把每个点的情况都计算一遍维护最值，一个是根据左子树整体情况和右子树整体情况得到当前树的整体情况。
>  递很像回溯算法，归很像动态规划算法。




## 核心代码

```python
def dfs(node):
    if not node: return 0 (或者 base case)
    
    # 1. 【问子树】：先拿到左右孩子的结果
    left_res = dfs(node.left)
    right_res = dfs(node.right)
    
    # 2. 【处理当前】：结合左右结果和 node.val，计算某种逻辑（比如最大路径）
    # 这里通常会更新全局 ans
    
    # 3. 【向上汇报】：把以我为根的最优结果返回给父节点
    return calculate(left_res, right_res, node.val)

def dfs(node, path_state):
    if not node: return
    
    # 1. 【处理当前】：结合父节点传来的 path_state 和 node.val 更新状态
    new_state = update(path_state, node.val)
    
    # 2. 【维护全局】：如果满足条件，更新全局 ans
    if check(new_state): nonlocal ans; ans = ...
    
    # 3. 【传给子树】：带着新状态继续往下
    dfs(node.left, new_state)
    dfs(node.right, new_state)
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 学会递和归理解本质



## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        ans = 0

        if not root:

            return 0

        def dfs(node,mx,mn):

            if not node:

                nonlocal ans

                ans = max(ans,mx - mn)

                return

            mn = min(mn,node.val)

            mx = max(mx,node.val)

            dfs(node.left,mx,mn)

            dfs(node.right,mx,mn)

        dfs(root,root.val,root.val)

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这题我用的递，把状态往下传，好思考一点



## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, val=0, left=None, right=None):

#         self.val = val

#         self.left = left

#         self.right = right

class Solution:

    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -> Optional[TreeNode]:

        if not root:

            return

        if depth == 1:

            return TreeNode(val,root,None)

        if depth == 2:

            root.left = TreeNode(val,root.left,None)

            root.right = TreeNode(val,None,root.right)

        else:

            root.left = self.addOneRow(root.left,val,depth - 1)

            root.right = self.addOneRow(root.right,val,depth - 1)

        return root
        
        if depth == 1:
            return TreeNode(val,root,None)
        def dfs(node,dep):
            if not node:
                return 
            if dep == depth - 1:
                l = node.left
                r = node.right
                node.left = TreeNode(val,l,None)
                node.right = TreeNode(val,None,r)
            dfs(node.left,dep + 1)
            dfs(node.right,dep + 1)
        dfs(root,1)
        return root       
        
        

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 依然递归也有很多思路





## 核心代码

```python

# Definition for a binary tree node.

# class TreeNode:

#     def __init__(self, x):

#         self.val = x

#         self.left = None

#         self.right = None

  

class Solution:

    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:

        if original is None or original is target:

            return cloned

        return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 思路，思路，我需要思路
































