这三道题（**LC 543 二叉树的直径**、**LC 687 最长同值路径**、**LC 124 二叉树中的最大路径和**）是二叉树 **“路径问题”** 中最经典的三剑客。

它们共享同一个核心思想：**“枚举拐点”（One Pass with Global Variable）**。

以下是为你总结的算法笔记。

---

# 算法笔记：二叉树路径问题通解 (Binary Tree Path Problems)

## 1. 核心思维模型：倒 V 字型 (The Arch)

这类问题的路径通常允许“从左子树上来，经过当前节点，再下到右子树去”。这形成了一个 **倒 V 字型（Arch）** 的路径。

**解题的关键在于：**

1. **遍历方式**：**后序遍历 (Post-order)**。因为我们需要先知道左右子树的情况，才能计算经过当前节点的路径。
    
2. **角色的分裂**：对于每一个节点 `node`，它同时扮演两个角色：
    
    - **角色 A (作为拐点/根)**：试图将左右两条最长路径连起来，挑战全局最大值 `ans`。公式通常是：`Left + Right + Node`。
        
    - **角色 B (作为子路)**：只能选择**其中一条**最长的路（左边或右边）贡献给它的父节点。因为它不能分叉。公式通常是：`max(Left, Right) + Node`。
        

## 2. 通用代码模版

这三道题的代码结构完全一致，只有计算逻辑不同：

Python

```
class Solution:
    def solve(self, root):
        self.ans = -float('inf') # 或者是 0，取决于题目
        
        def dfs(node):
            if not node:
                return 0 # 或者是 -1，取决于边还是点
            
            # 1. 递归拿到左右子树贡献的“单边最大值”
            l = dfs(node.left)
            r = dfs(node.right)
            
            # 【核心差异区】开始
            # 这里可能需要根据题目逻辑（如是否同值、是否大于0）
            # 对 l 和 r 进行“预处理”或“重置”
            # 【核心差异区】结束
            
            # 2. 更新全局结果 (连接左右，形成倒V)
            # 当前节点作为路径最高点（拐点）
            self.ans = max(self.ans, l + r + val_correction)
            
            # 3. 返回给父节点 (只能选一边)
            # 必须包含当前节点自己
            return max(l, r) + val_correction
            
        dfs(root)
        return self.ans
```

---

## 3. 三题深度对比与细节总结

### A. 二叉树的直径 (LC 543)

- **目标**：找最长路径的**边数**。
    
- **DFS 返回值**：以当前节点为终点的最长路径的**深度（节点数或边数）**。
    
- **你的代码技巧**：
    
    - 你用了 `if node is None: return -1` 且每次 `+1`。
        
    - 这是一种计算**边数**的巧妙写法。
        
    - `dfs(叶子)` 返回 `0` (因为 `-1 + 1`)，代表叶子节点往下没有边。
        
- **关键公式**：
    
    - 全局更新：`l_len + r_len` (左边深度 + 右边深度)
        
    - 返回父节点：`max(l_len, r_len) + 1`
        

### B. 最长同值路径 (LC 687)

- **目标**：路径上所有节点值必须相同，求最长**边数**。
    
- **DFS 返回值**：以当前节点为起点，向下延伸的同值路径最长长度。
    
- **核心逻辑（截断）**：
    
    - 这是本题最难点。虽然我们也递归拿到了 `l_max` 和 `r_max`，**但是**，如果 `node.left.val != node.val`，那么左边的路就断了！
        
    - **处理方式**：
        
        Python
        
        ```
        if node.left and node.left.val != node.val:
            l_max = 0 # 强制置 0，因为断开了
        ```
        
- **注意**：你的代码中，DFS 返回的是“经过计算后的长度”（即已经 +1 了）。另一种写法是 DFS 返回单纯的高度，在当前层判断值是否相等来决定是 `+1` 还是 `0`。你的写法也是完全正确的，且逻辑很清晰。
    

### C. 二叉树中的最大路径和 (LC 124)

- **目标**：路径上节点值之和最大（节点值可能有负数）。
    
- **DFS 返回值**：以当前节点为终点的最大单边路径和。
    
- **核心逻辑（负数处理/贪心）**：
    
    - 如果子树贡献的路径和是**负数**，那我们要它干嘛？直接丢弃（当作 0）。
        
    - **你的代码亮点**：
        
        Python
        
        ```
        return max(max(l,r) + root.val, 0)
        ```
        
        你在**返回给父节点时**做了截断（与 0 取 max）。这意味着父节点收到的 `l` 和 `r` 永远是非负的。
        
    - **全局更新**：`ans = max(ans, l + r + root.val)`。因为 `l` 和 `r` 已经被处理过非负了，所以这里直接加没问题。
        

---

## 4. 易错点与思考清单 (Checklist)

在做这类题时，如果不确定，请按以下步骤自问：

1. **算点还是算边？**
    
    - **算点**：Base case `return 0`，递归回来 `+1`。结果通常是 `Left + Right + 1`。
        
    - **算边**：Base case `return -1` (你的写法) 或者结果计算时不用 `+1`。
        
    - _LC 124 是算点权之和，LC 543/687 是算边长度。_
        
2. **路径是否可以为负？**
    
    - 如果节点有负值（如 LC 124），必须考虑“舍弃子树”的情况（`max(x, 0)`）。
        
    - 如果不舍弃，路径和反而变小，不如不走那条路。
        
3. **是否依赖节点值 (Value Constraints)？**
    
    - 如果像 LC 687 那样要求同值，必须在计算 `ans` 和 `return` 之前，判断父子节点值是否相等。如果不等，子树贡献归零。
        
4. **全局变量的位置**
    
    - 使用 `self.ans` 或者 `nonlocal ans`。不要试图通过 DFS 的返回值来传递这个“倒 V 型”的最大值，因为 DFS 的返回值必须是“单条腿”的长度，否则父节点没法接。
        

## 5. 一句话总结

> **“自底向上做递归，左右单腿传父辈；中间连接算全局，负数截断如果不配。”**