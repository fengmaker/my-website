

## 核心代码

```python

class Solution:

    def isValid(self, s: str) -> bool:

        if len(s) % 2:

            return False

        st = []

        mp = {"]":"[","}":"{",")":"("}

        for c in s:

            if c not in mp:

                st.append(c)

            elif not st or st.pop() != mp[c]:

                return False

        return len(st) == 0

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 可以用字典记录相应的括号，加快判断   注意条件判断 如果为空 或者栈顶与当前括号不匹配 这个代码右括号不会入栈



## 核心代码

```python

class Solution:

    def minAddToMakeValid(self, s: str) -> int:

        level = ans = 0

        for c in s:

            if c == "(":

                level += 1

            elif level:

                level -= 1

            else:

                ans += 1

        return ans + level

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 括号匹配，这里字符串不一定合法，需要注意，常用level表示嵌套深度



## 核心代码

```python
class Solution:

    def removeOuterParentheses(self, s: str) -> str:

        ans = ""

        st = []

        for c in s:

            if c == "(":

                if st:

                    ans += c

                st.append(c)

            else:

                st.pop()

                if st:

                    ans += c

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意这题，只需删除最外层括号，题目保证字符串一定合法，那就只需在入栈前出栈后判断就行



## 核心代码

```python
class Solution:

    def maxDepth(self, s: str) -> int:

        level = 0

        ans = 0

        for c in s:

            if c == "(":

                level += 1

                ans = max(level,ans)

            elif c == ")":

                level -= 1

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 判断嵌套深度可用level记录左括号的个数



## 核心代码

```python


class Solution:

    def reverseParentheses(self, s: str) -> str:

        st = []

        for c in s:

            if c != ")":

                st.append(c)

            else:

                tmp = []

                while st[-1] != "(":

                    tmp.append(st.pop())

                st.pop()

                st += tmp

        return "".join(st)
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 反转每对括号间的子串，在新的嵌套深度下，创建临时栈存放反转数据后再放回原栈，一层一层处理，这个思路要记住



## 核心代码

```python

class Solution:

    def reverseParentheses(self, s: str) -> str:

        st = []

        n = len(s)

        pair = [0] * n

        for i in range(n):

            if s[i] == "(":

                st.append(i)

            if s[i] == ")":

                j = st.pop()

                pair[i] = j

                pair[j] = i

        index = 0

        step = 1

        ans = []

        while index < n:

            if s[index] == "(" or s[index] == ")":

                index = pair[index]

                step = -step

            else:

                ans.append(s[index])

            index += step

        return "".join(ans)

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 有$O(N)$做法，预处理每对括号的下标进行跳转



## 核心代码

```python

class Solution:

    def scoreOfParentheses(self, s: str) -> int:

        st = [0]

        for c in s:

            if c == "(":

                st.append(0)

            else:

                x = st.pop()

                st[-1] += max(2 * x,1)

        return st[-1]

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这道题好难，现在还不知道怎么深刻理解






## 核心代码

```python
class Solution:

    def minRemoveToMakeValid(self, s: str) -> str:

        left,right,ans = 0,s.count(")"),""

        for c in s:

            if c == "(":

                if right > 0:

                    ans += c

                    left += 1

                    right -= 1

            elif c == ")":

                if left > 0:

                    ans += c

                    left -= 1

                else:

                    right -= 1

            else:

                ans += c

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 之前做过一个移除无效括号所需最短长度，现在要找到并删除，这种算法好理解，当然还有栈的算法，可以学习一下































