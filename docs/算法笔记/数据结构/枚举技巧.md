

## 核心代码

```python


class Solution:

    def minimumCardPickup(self, cards: List[int]) -> int:

        ans = inf

        cnt = defaultdict()

        for i,x in enumerate(cards):

            if x in cnt:

                ans = min(ans,i - cnt[x] + 1)

            cnt[x] = i

        return ans if ans < inf else -1
```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意判断在不在哈希表中，什么时候判断哈希表的值，什么时候只需在哈希表中



## 核心代码

```python
class Solution:

    def pairSums(self, nums: List[int], target: int) -> List[List[int]]:

        ans = []

        cnt = defaultdict(int)

        for x in nums:

            if cnt[target - x]:

                cnt[target - x] -= 1

                ans.append([target - x,x])

            else:

                cnt[x] += 1

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这题就需要判断哈希表的值，一定要确定这个数还有，而不是说存在键中，因为会用掉








## 核心代码

```python

class Solution:

    def maxOperations(self, nums: List[int], k: int) -> int:

        ans = 0

        cnt = defaultdict(int)

        for x in nums:

            if cnt[k - x]:

                ans += 1

                cnt[k - x] -= 1

            else:

                cnt[x] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 同样，这题这是关于数量的，会移出数组




## 核心代码

```python

class Solution:

    def maxSum(self, nums: List[int]) -> int:

        ans = -1

        cnt = defaultdict(int)

        for x in nums:

            key = max(map(int,str(x)))

            if key in cnt:

                ans = max(ans,cnt[key] + x )

            cnt[key] = max(cnt[key],x)

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 记住map的经典用法，还有这里的cnt记录每个满足要求的前面的数的最大值，因为我们只需要这个，注意这个思路，很常见，也是枚举右，维护左，很棒



## 核心代码

```python

class Solution:

    def countTrapezoids(self, points: List[List[int]]) -> int:

        MOD = 10 ** 9 + 7

        ans = s = 0

        cnt = defaultdict(int)

        for x,y in points:

            cnt[y] += 1

        for c in cnt.values():

            k = c * (c - 1) // 2

            ans += s * k

            s += k

        return ans % MOD

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 思路太精妙了，避免了枚举第一个的讨论会不会和自己乘，同时用s直接维护前缀和，不用二重循环







## 核心代码

```python

class Solution:

    def countBadPairs(self, nums: List[int]) -> int:

        ans = 0

        n = len(nums)

        cnt = defaultdict(int)

        for i,x in enumerate(nums):

            if x - i in cnt:

                ans += cnt[x - i]

            cnt[x - i] += 1

        return n * (n - 1) // 2 - ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 正难则反，需要注意，式子变形，看当前下标和之前下标满足什么式子



## 核心代码

```python

class Solution:

    def getLargestOutlier(self, nums: List[int]) -> int:

        cnt = Counter(nums)

        total = sum(nums)

        ans = -inf

        for x in nums:

            cnt[x] -= 1

            if (total - x) % 2 == 0 and cnt[(total - x) // 2] > 0:

                ans = max(ans,x)

            cnt[x] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 枚举异常值 很棒，在其他数中找符合要求的值，如果满足就说明符合要求。先全部放进cnt，然后滑动枚举‘






## 核心代码

```python
class Solution:

    def maximumProduct(self, nums: List[int], m: int) -> int:

        ans = mx = -inf

        mn = inf

        for i in range(m - 1,len(nums)):

            y = nums[i - m + 1]

            mn = min(mn,y)

            mx = max(mx,y)

            x = nums[i]

            ans = max(ans,x * mn,x * mx)

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 注意子序列的定义，大小为m，说明下标至少要差i - m + 1 两个数乘积，枚举其中一个，只需考虑另外一个的性质 这是精髓




## 核心代码

```python
class Solution:

    def numPairsDivisibleBy60(self, time: List[int]) -> int:

        ans = 0

        cnt = defaultdict(int)

        for t in time:

            ans += cnt[(60 - (t % 60)) % 60]

            cnt[t % 60] += 1

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 特别处理 mod 60 情况



## 核心代码

```python

class Solution:

    def countBeautifulPairs(self, nums: List[int]) -> int:

        cnt = defaultdict(int)

        ans = 0

        for x in nums:

            for y,c in cnt.items():

                if c and gcd(y,x % 10) == 1:

                    ans += c

            while x >= 10:

                x //= 10

            cnt[x] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 需要遍历字典就直接遍历，不要犹豫，还有如果知道范围，可以直接指定数组大小











## 核心代码

```python

class Solution:

    def similarPairs(self, words: List[str]) -> int:

        ans = 0

        cnt = defaultdict(int)

        for w in words:

            key = 0

            for c in w:

                key |= 1 << (ord(c) - ord('a'))

            ans += cnt[key]

            cnt[key] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这里位掩码技巧很好用，需要熟练    1 << (ord(c) - ord('a'))




## 核心代码

```python

class Solution:

    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int: #

        s = list(accumulate(nums,initial = 0))

        ans = 0

        def f(firstLen,secondLen):

            nonlocal ans

            maxsuma = 0

            for i in range(firstLen + secondLen,len(s)):

                maxsuma = max(maxsuma,s[i - secondLen] - s[i - secondLen - firstLen])

                ans = max(ans,maxsuma + s[i] - s[i - secondLen])

        f(firstLen,secondLen)

        f(secondLen,firstLen)

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 前缀和需要注意，加0在首位，然后s[i] - s[i - k]所在的区间和为左开右闭区间，即[i - k,i)



## 核心代码

```python

class Solution:

    def minimumSum(self, nums: List[int]) -> int:

        n = len(nums)

        ans = inf

        pre = nums[0]

        suf = [0] * n

        suf[-1] = nums[-1]

        for i in range(n - 2,-1,-1):

            suf[i] = min(suf[i + 1],nums[i])

        for j in range(1,len(nums) - 1):

            if nums[j] > pre and nums[j] > suf[j + 1]:

                ans = min(ans,nums[j] + pre + suf[j + 1])

            pre = min(pre,nums[j])

        return ans if ans < inf else -1

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 前后缀分解，需要前缀后缀最大值或最小值的可以用数组存起来，当然跟着遍历顺序，可以省一个数组， 初始化为0是可行的，因为是从一开始的值一路比较下来的


## 核心代码

```python

class Solution:

    def countPalindromicSubsequence(self, s: str) -> int:

        suf = Counter(s)

        pre = defaultdict(int)

        ans = 0

        st = set()

        for c in s:

            suf[c] -= 1

            for key in pre:

                if suf[key] and (c,key) not in st:

                    ans += 1

                    st.add((c,key))

            pre[c] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这题还有位运算优化算法，可以后面再说



## 核心代码

```python
class Solution:

    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:

        col_sum = [sum(col) - 1 for col in zip(*grid)]

        ans = 0

        for row in grid:

            row_sum = sum(row) - 1

            ans += row_sum * sum(cs for x,cs in zip(row,col_sum) if x)

        return ans


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这题不错，想清楚每一个直角顶点贡献多少答案，就行，





## 核心代码

```python

class Solution:

    def numberOfBoomerangs(self, points: List[List[int]]) -> int:

        ans = 0

        for x1,y1 in points:

            cnt = defaultdict(int)

            for x2,y2 in points:

                d = (x1 - x2) ** 2 + (y1 - y2) ** 2

                ans += 2 * cnt[d]

                cnt[d] += 1

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 这个题每次都做不出来，需要注意




## 核心代码

```python
class Solution:

    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:

        m,n = len(grid),len(grid[0])

        for k in range(1,m + n):

            min_j = max(n - k,0)

            max_j = min(m + n - 1 - k,n - 1)

            a = [grid[k + j - n][j] for j in range(min_j,max_j + 1)]

            a.sort(reverse = min_j == 0)

            for j,val in zip(range(min_j,max_j + 1),a):

                grid[k + j - n][j] = val

        return grid


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 遍历对角线，注意i - j是定值



## 核心代码

```python
class Solution:

    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:

        # k = i - j + n

        m,n = len(grid),len(grid[0])

        # j = i - k + n

        for k in range(1,m + n):

            min_j = max(n - k,0)

            max_j = min(m + n - 1 - k,n - 1)

            a = [grid[j + k - n][j] for j in range(min_j,max_j + 1)]

            left = set()

            cnt = Counter(a)

            for i,x in enumerate(a):

                cnt[x] -= 1

                if cnt[x] == 0:

                    del cnt[x]

                a[i] = abs(len(left) - len(cnt))

                left.add(x)

            for j,val in zip(range(min_j,max_j + 1),a):

                grid[j + k - n][j] = val

        return grid


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 遍历矩阵对角线有技巧，需要记住

































































