这是一份基于你提供的资料整理的**前缀和（Prefix Sum）**学习笔记。

---

# 算法笔记：一维前缀和 (Prefix Sum)

## 1. 核心思想
**前缀和**的主要用途是快速计算数组中任意**连续子数组**的元素和。

*   **直观理解**：
    想要计算子数组 `[3, 4, 5]` 的和，不需要重新遍历相加。
    可以用前缀 `[1, 2, 3, 4, 5]` 的和，减去前缀 `[1, 2]` 的和。
    即：
    $$Sum([3,4,5]) = Sum([1..5]) - Sum([1..2])$$
*   **本质**：
    任意子数组的元素和，都可以表示为**两个前缀和的差**。

## 2. 定义与构建

设原数组为 $a$（或 `nums`），长度为 $n$。
我们构建一个**长度为 $n+1$** 的前缀和数组 $s$。

### 2.1 定义
$s[i]$ 表示 $a$ 的**前 $i$ 个元素**的和。

*   $s[0] = 0$ （**哨兵**，表示前 0 个数的和，处理边界情况非常重要）
*   $s[1] = a[0]$
*   $s[i] = a[0] + a[1] + \dots + a[i-1]$

### 2.2 递推公式 (预处理)
根据定义，前 $i+1$ 个数的和 = 前 $i$ 个数的和 + 第 $i+1$ 个数值（即 $a[i]$）。
$$s[i+1] = s[i] + a[i]$$

**对应代码逻辑**：
```python
# 假设 nums = [1, 2, 3]
n = len(nums)
s = [0] * (n + 1)
for i in range(n):
    s[i + 1] = s[i] + nums[i]
# s 变为 [0, 1, 3, 6]
```

## 3. 区间求和公式

有了数组 $s$，我们可以在 $O(1)$ 时间内求出任意区间的和。

### 3.1 闭区间 `[left, right]`
若需要计算下标 `left` 到 `right`（包含两端）的元素和：
*   公式：**`s[right + 1] - s[left]`**
*   **推导**：
    *   $s[right+1]$ 代表前 $right+1$ 个数（下标 $0 \sim right$）的和。
    *   $s[left]$ 代表前 $left$ 个数（下标 $0 \sim left-1$）的和。
    *   相减即得下标 $left \sim right$ 的和。

### 3.2 左闭右开区间 `[left, right)`
若下标区间定义为左闭右开（包含 `left`，不包含 `right`）：
*   公式：**`s[right] - s[left]`**
*   **优势**：不需要对下标进行 `+1` 或 `-1` 的调整，代码更为整洁。

牢记初始值一定为0 索引下标不再求和数组中



## 核心代码

```python

class Solution:

    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        xors = [0]

        for x in arr:

            xors.append(xors[-1] ^ x)

        return [xors[l] ^ xors[r + 1] for l,r in queries]

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 总结子数组的异或和 需要注意 不再是减法 而是直接 异或

这是一份关于**前缀异或（Prefix XOR）**及其核心运算性质的总结笔记。

---

# 算法笔记：前缀异或 (Prefix XOR)

## 1. 代码逻辑解析
你提供的 Python 代码是解决“子数组异或查询”问题的标准模版。其核心逻辑完全照搬了普通前缀和的思想，只是将运算符号从加号 `+` 换成了异或 `^`。

### 核心步骤
1.  **初始化**：`xors = [0]`。
    *   这里的 `0` 是异或运算的**单位元**（相当于加法中的 0，乘法中的 1）。
2.  **构建前缀数组**：`xors.append(xors[-1] ^ x)`。
    *   `xors[i]` 表示原数组前 `i` 个元素的异或和。
    *   递推公式：$P[i] = P[i-1] \oplus \text{nums}[i-1]$。
3.  **区间查询**：`xors[l] ^ xors[r + 1]`。
    *   求区间 `[l, r]` 的异或和。
    *   利用了异或的**自反性**（即减法性质），通过再次异或左边的前缀来“抵消”它。

---

## 2. 异或运算 (`XOR`) 详解

异或（Exclusive OR），在编程语言中通常用符号 **`^`** 表示，在数学中常用 $\oplus$ 表示。

### 2.1 基本定义
*   **二进制位运算**：对两个数的二进制位进行逐位比较。
*   **口诀**：**相同为 0，不同为 1**。
*   **进阶理解**：异或也可以被视为**不进位的二进制加法**。

| A | B | A ^ B | 说明 |
| :-: | :-: | :-: | :--- |
| 0 | 0 | **0** | 相同 |
| 0 | 1 | **1** | 不同 |
| 1 | 0 | **1** | 不同 |
| 1 | 1 | **0** | 相同 |

### 2.2 核心性质 (关键结论)

这是理解为什么前缀和可以用于异或的基石：

1.  **归零律（自反性）** —— **最重要！**
    $$x \oplus x = 0$$
    *   任何数和自己异或，结果为 0。
    *   *应用*：这使得异或运算成为了它自己的“逆运算”。在普通前缀和中我们用减法抵消前缀，在异或中，我们用“再异或一次”来抵消前缀。

2.  **恒等律**
    $$x \oplus 0 = x$$
    *   任何数和 0 异或，保持不变。
    *   *应用*：这就是为什么前缀数组初始化要放一个 `0` (`xors = [0]`)。

3.  **交换律与结合律**
    $$a \oplus b = b \oplus a$$
    $$(a \oplus b) \oplus c = a \oplus (b \oplus c)$$
    *   *应用*：计算顺序不影响结果。

---

## 3. 前缀异或原理推导

假设我们要计算数组 `arr` 在区间 `[L, R]` 内的异或和。

### 符号定义
*   令 $P[i]$ 为前 $i$ 个数的异或前缀和（对应代码中的 `xors[i]`）。
    *   $P[L] = arr[0] \oplus arr[1] \oplus \dots \oplus arr[L-1]$
    *   $P[R+1] = arr[0] \oplus arr[1] \oplus \dots \oplus arr[L-1] \oplus arr[L] \oplus \dots \oplus arr[R]$

### 推导过程
我们需要求的是部分：$Q = arr[L] \oplus \dots \oplus arr[R]$。

利用性质 $x \oplus x = 0$ 和 $x \oplus 0 = x$，我们可以计算 $P[R+1] \oplus P[L]$：

$$
\begin{aligned}
P[R+1] \oplus P[L] &= (\underbrace{arr[0] \oplus \dots \oplus arr[L-1]}_{\text{第一部分}} \oplus \underbrace{arr[L] \oplus \dots \oplus arr[R]}_{\text{第二部分(目标)}}) \oplus (\underbrace{arr[0] \oplus \dots \oplus arr[L-1]}_{\text{第一部分}}) \\
&= (\text{第一部分} \oplus \text{第一部分}) \oplus \text{第二部分} \\
&= 0 \oplus \text{第二部分} \\
&= \text{第二部分}
\end{aligned}
$$

### 结论
区间 `[L, R]` 的异或和等于：
$$P[R+1] \oplus P[L]$$

这就是代码中 `xors[r + 1] ^ xors[l]` 的数学依据。

---

## 4. 总结对比：普通前缀和 vs 前缀异或

| 特性 | 普通前缀和 (Sum) | 前缀异或 (XOR) |
| :--- | :--- | :--- |
| **运算符号** | `+` (加) | `^` (异或) |
| **逆运算** | `-` (减) | `^` (异或本身) |
| **哨兵初始值** | `0` (加法单位元) | `0` (异或单位元) |
| **构建公式** | `s[i] = s[i-1] + nums[i-1]` | `x[i] = x[i-1] ^ nums[i-1]` |
| **区间 [L, R] 公式** | **`s[R+1] - s[L]`** | **`x[R+1] ^ x[L]`** |

### 记忆口诀
> **“异或的逆运算就是它自己。”**
> 所以求区间异或，只需将**右端点的前缀**与**左端点的前缀**再次异或即可。




## 核心代码

```python
class Solution:

    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:

        s = list(accumulate((x % 2 == y % 2 for x,y in pairwise(nums)),initial = 0))

        return [s[f] == f[to] for f,to in queries]


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 转化建模思路，建模为0-1，然后求和为0的连续子数组 将连续子数组的性质转化以后遇到**静态数组**的**区间判定**问题：先问自己：**“能否找到一个简单的条件，把它变成 0 和 1 的计数问题？”**
如果能，立刻上**前缀和**。








## 核心代码

```python
class Solution:

    def maxAbsoluteSum(self, nums: List[int]) -> int:

        s = list(accumulate(nums,initial = 0))

        return max(s) - min(s)


```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 子数组的和   前缀和 o1查询 绝对值最大化，在前缀和数组找两个值差最大



## 核心代码

```python

class Solution:

    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        nxt = list(accumulate(nextCost + nextCost,initial = 0))

        pre = list(accumulate(previousCost + previousCost))

        ans = 0

        ord_a = ord('a')

        for x,y in zip(s,t):

            x = ord(x) - ord_a

            y = ord(y) - ord_a

            ans += min(nxt[y + 26 if y < x else y] - nxt[x],

                       pre[x + 26 if x < y else x] - pre[y])

        return ans

```
##  核心结论 (One-Liner)

> [!summary] 本题考点
> 循环可以加一个数组在后面，保持连续 然后通过+26到指定位置













