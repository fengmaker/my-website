这是一个非常漂亮的刷题清单！从 1300 分到 nearly 1800 分，你已经把图论中最核心的 **DFS（深度优先搜索）** 相关的“连通性”和“路径”问题扫了一遍。

现在是你构建**知识体系**的最佳时机。我为你总结一份**《图论 DFS 算法笔记》**，并提供两套最通用的模版，足以秒杀 90% 的中等难度图论题。

---

### 第一部分：图论 DFS 算法笔记

做图论题，脑子里永远要有这 **三步走** 的流程：

#### 1. 建图 (Build Graph)

这是起手式。除非题目给的就是邻接表（如 `797. 所有可能的路径`），否则 99% 的情况都需要先建图。

- **输入形式**：通常是 `edges = [[u, v], ...]`。
    
- **存储结构**：**邻接表 (Adjacency List)** 是永远的神。
    
- **代码习惯**：
    
    Python
    
    ```
    g = [[] for _ in range(n)] # 0到n-1
    for u, v in edges:
        g[u].append(v)
        g[v].append(u) # 注意：无向图双向加，有向图单向加
    ```
    

#### 2. 确定 `visited` 的策略 (The Strategy)

这是最容易晕的地方，也是 DFS 的核心。根据题目要求，`visited` 分为三种模式：

|**模式**|**这里的 visited 是什么？**|**适用场景**|**代表题**|
|---|---|---|---|
|**全图标记** (Global)|**“染过色就不碰了”**。记录**历史**访问过的点。|求连通块个数、大小、连通块内的属性（最小边/点数）、判断连通性。|省份数量、钥匙和房间、跳跃游戏|
|**路径标记** (Path)|**“这条路走过，但别的路还能来”**。记录**当前**递归栈上的点。|求**所有**路径、检测环、拓扑排序。需要**回溯**。|所有可能的路径 (797)|
|**本轮标记** (Session)|**“这次查询不用再算，但下次查询还要算”**。|对每个点发起一次全新的搜索（如找祖先）。|节点的所有祖先 (2192)|

#### 3. 提取信息 (Extract Info)

在 DFS 过程中，你通常需要顺手干点什么：

- **计数**：`size += 1` (统计连通块大小，如 `2316`)
    
- **求最值**：`min_val = min(w, min_val)` (如 `2492`)
    
- **收集节点**：`nodes.append(x)` (收集连通块里的点，如 `3310`)
    

---

### 第二部分：通用代码模版

我把模版精简为两套：**“连通块模版”**（覆盖你清单里 80% 的题）和 **“路径回溯模版”**。

#### 模版一：连通块/可达性 DFS (最常用)

**适用题目**：省份数量、无法互相到达点对数、连通网络操作次数、最小分数、移除可疑方法、完全连通分量。

**特点**：

- `visited` 是全局的。
    
- 主循环遍历 `0` 到 `n-1`，没访问过就启动一次 DFS（发现新大陆）。
    

Python

```
class Solution:
    def solve(self, n: int, edges: List[List[int]]) -> int:
        # 1. 建图
        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u) # 根据题意决定是否双向
            
        visited = [False] * n
        ans = 0 
        
        # 定义 DFS
        def dfs(x):
            visited[x] = True
            
            # ---【在这里处理当前节点 x 的业务逻辑】---
            # 例如：size += 1
            # 或者：current_component_nodes.append(x)
            
            for y in g[x]:
                if not visited[y]:
                    dfs(y)
                    
            # ---【不需要回溯 (不需要 visited[x] = False)】---
        
        # 2. 主循环：扫描所有点
        for i in range(n):
            if not visited[i]:
                # 发现一个新的连通块
                # ---【可以在这里初始化连通块的统计变量】---
                dfs(i)
                ans += 1 # 统计连通块数量
                
        return ans
```

#### 模版二：所有路径/回溯 DFS

**适用题目**：所有可能的路径 (797)。

**特点**：

- 需要记录 `path`。
    
- **必须回溯**：递归回来要把状态复原，为了让别人也能走这条路。
    

Python

```
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        target = len(graph) - 1
        ans = []
        path = [0] # 路径包含起点
        
        def dfs(x):
            if x == target:
                ans.append(list(path)) # ⚠️ 必须拷贝 path[:]
                return
            
            for y in graph[x]:
                path.append(y) # 做选择
                dfs(y)         # 进递归
                path.pop()     # 撤销选择 (回溯)
        
        dfs(0)
        return ans
```

---

### 第三部分：针对你清单中易错点的“避坑指南”

根据你之前练习中遇到的问题，这里有几条针对性的总结：

1. **关于 `return` 和 `visited` 的配合 (1971. 寻找路径)**
    
    - **技巧**：如果你只是想找“能不能到终点”，可以在 DFS 内部写 `if x == end: return True`，并且利用 `if dfs(y): return True` 层层向上传递好消息。
        
    - **优化**：一旦找到，立刻停止后续所有搜索（剪枝）。
        
2. **关于 DAG 图找祖先 (2192. 祖先)**
    
    - **陷阱**：有向无环图（DAG）虽然没有环，但存在“多路径汇聚”（菱形结构）。
        
    - **对策**：依然需要 `visited` 数组，防止重复计算同一个祖先节点导致超时。
        
    - **特殊**：因为是找“每个节点”的祖先，所以对于每个 `i` 的 DFS，`visited` 都要重置（`vis = [False] * n`）。
        
3. **关于 Set vs List (3310. 移除可疑方法)**
    
    - **原则**：节点编号是 `0` 到 `n-1` 的连续整数，**无脑用 `List`**。快且省。
        
    - **原则**：节点是字符串、或者稀疏大整数，**只能用 `Set`**。
        
    - **代码**：用 List 时，判断写法是 `if not visited[y]`；用 Set 时，判断写法是 `if y not in visited`。
        
4. **关于“完全连通分量” (2685. 统计完全连通分量的数量)**
    
    - 这道题你清单里有，但可能还没细究。
        
    - **思路**：利用模版一提取连通块的信息。
        
    - **判定**：一个连通块里如果有 `v` 个节点，要是“完全连通”，它的边数 `e` 必须等于 `v * (v - 1) / 2`。在 DFS 过程中顺便统计节点数和边数即可。
        

### 下一步建议

你的基础已经非常扎实了。接下来你可以：

1. **做一道综合题检验模版**：**2685. 统计完全连通分量的数量**。试着套用模版一，在 DFS 过程中统计点数和边数。
    
2. **开始接触 BFS 最短路**：图论的另一半江山。你可以从 **1926. 迷宫中离入口最近的出口** 开始，感受 BFS 的层序遍历特性。