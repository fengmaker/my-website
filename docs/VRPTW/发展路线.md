这是一个非常清晰且符合运筹学认知规律的结构。这种从**“边的视角”**到**“路径视角”**的转变，正是理解大规模 VRP 求解技术的关键。

按照你的要求，我将 VRPTW 精确算法的演变史重构为四个阶段。这将为你后续构建 Solver 提供宏观指导。

---

### 第一阶段：紧致模型时代 (The Era of Compact Formulations)

时间跨度： 1950s - 1980s

核心逻辑： 试图用一个多项式级别的数学模型描述整个问题，完全依赖通用 MIP 求解器（如 Cplex/Gurobi）的黑盒能力。

**关键词：** Three-Index Flow, Big-M, Linear Relaxation (LP Relaxation)

#### 1. 三指标流模型 (Three-Index Flow Formulation)

这是教科书中最直观的模型。

- **变量：** $x_{ijk} \in \{0,1\}$，表示第 $k$ 辆车是否从 $i$ 走到 $j$。
    
- 时间窗约束：
    
    $$t_{ik} + c_{ij} - M(1-x_{ijk}) \leq t_{jk}$$
    
- **致命缺陷：** **Big-M (大M法)**。
    
    - 为了让约束在 $x=0$ 时失效，必须引入一个巨大的常数 $M$。
        
    - 在**线性松弛 (LP Relaxation)** 中，为了满足不等式，求解器往往只需要让 $x_{ijk}$ 取一个极小的小数（例如 $0.001$）。
        
    - **后果：** 算出来的下界（Lower Bound）非常差（Loose），导致 Branch-and-Bound 树在根节点附近根本剪不了枝，搜索空间呈指数级爆炸。
        
- **能力上限：** 只能解 **15-25 个点** 的规模。
    

---

### 第二阶段：割平面时代 (The Era of Branch-and-Cut)

时间跨度： 1980s - 1990s

核心逻辑： 既然紧致模型的 LP 松弛太差，那就通过不断添加有效不等式 (Valid Inequalities) 来切掉非整数解，逼近整数凸包。

**关键词：** Polyhedral Combinatorics, Separation, k-Path Cuts

#### 1. 针对 VRP 的特殊割平面

除了 TSP 中经典的子回路消除割（SEC），学者们针对 VRP 发明了特定割平面：

- **容量割 (Capacity Cuts / Rounded Capacity Inequalities):** 如果一个客户集合的需求总量 $D(S)$ 超过了车辆容量 $Q$，那么进出这个集合的车辆数必须 $\geq \lceil D(S)/Q \rceil$。
    
- **局限性：** 这种方法在 CVRP（纯容量限制）上效果不错，但在 VRPTW 上遭遇滑铁卢。
    
    - **原因：** 时间窗约束很难转化成这种基于“边”的线性割平面。时间是一种**累积资源**，很难用简单的线性不等式切得干净。
        

---

### 第三阶段：分解与列生成时代 (The Era of Branch-and-Price)

时间跨度： 1990s - 2005

核心逻辑： 视角大反转。与其在原图中纠结“选哪条边”，不如直接决策“选哪条完整的路径”。利用 Dantzig-Wolfe 分解 将复杂性转移到子问题中。

**关键词：** Set Partitioning, Master Problem, Subproblem (ESPPRC), Label Setting

#### 1. 集合划分模型 (Set Partitioning Formulation)

这是现代 VRPTW 求解器的基石，彻底抛弃了 $x_{ij}$ 变量。

- 主问题 (Master Problem, RMP):
    
    $$\min \sum_{r \in \Omega} c_r \lambda_r$$
    
    $$\text{s.t.} \sum_{r \in \Omega} a_{ir} \lambda_r = 1, \quad \forall i \in \text{Customer}$$
    
- **变量含义：** $\lambda_r$ 是 0/1 变量，代表是否选择“路径 $r$”。
    
- **神奇之处（解耦）：**
    
    - 原本最恶心的“时间窗”、“容量”约束，从主问题中消失了！
        
    - 它们被封装进了 **路径 $r$ 的生成过程**（定价子问题）里。主问题只负责“拼图”。
        

#### 2. 定价子问题 (Pricing Subproblem)

- **任务：** 既然不能枚举所有路径 $\Omega$，我们就动态生成。每次找到一条 Reduced Cost 最负的合法路径加入 RMP。
    
- **算法：** **ESPPRC** (Elementary Shortest Path Problem with Resource Constraints)。
    
- **核心技术：** **Label Setting Algorithm (标签算法)**。
    
    - 你在图上走，带着一堆“资源标签”（当前时间、当前载重）。
        
    - **时间窗的逆袭：** 在紧致模型里，时间窗是敌人；但在标签算法里，时间窗是**神队友**。时间窗越窄，标签不仅无法延展（Infeasible），还能利用 Dominance Rule（优势准则）大量剪枝。
        

---

### 第四阶段：现代集大成时代 (The Era of Branch-Cut-and-Price)

时间跨度： 2006 - 至今

核心逻辑： 单纯的列生成会有“长尾效应”（收敛慢）。现在的 SOTA（如 VRPSolver / Pessoa et al. 2020）是第三阶段的集大成者，并引入了三个核武器。

**关键词：** ng-Route, Subset-Row Cuts, Bidirectional Labeling  
**关键词：** ng-Route，子集行切割，双向标记

#### 1. ng-Route 松弛 (ng-Route Relaxation)

- **痛点：** 求解“基本路径”（Elementary Path，不含环）是 NP-Hard 的，非常慢。
    
- **创新：** Baldacci 等人提出 **ng-Route**。允许路径里有环，但只能在“局部记忆”外有环。
    
- **效果：** 这是一个完美的 Trade-off。它比 q-route（允许任意环）紧得多，又比 Elementary Path 快几个数量级。
    

#### 2. 鲁棒割平面 (Robust Cuts / Subset-Row Cuts)

- **痛点：** 在列生成的主问题上加传统的割平面，会破坏子问题的结构（增加对偶变量，导致子问题变难）。
    
- **创新：** **Subset-Row Cuts (SRC)**。这是一种特殊的割平面，虽然它改变了子问题的对偶值，但可以通过修改标签算法的 Dominance Rule 来高效处理，不会破坏算法框架。
    

#### 3. 双向标签算法 (Bidirectional Labeling)

- **工业标准：** 现在的子问题不再是简单地从起点走到终点。而是：
    
    - **前向搜索 (Forward):** 从 Depot 出发走一半。
        
    - **后向搜索 (Backward):** 从 Depot 逆向走一半。
        
    - **对接 (Merge/Join):** 在中间点通过特定条件拼接。
        
- **效果：** 将搜索深度减半，搜索空间减少指数级。
    

---

### 总结：你的学习/复现路线图 (Roadmap)

如果要复现一个“教程级”的 VRPTW Solver，建议按照这个梯度进行：

1. **Level 1 (Gurobi 基础):**
    
    - 用 Python + `gurobipy` 实现 **MTZ 模型**。
        
    - _目标：_ 跑一个 Solomon C101 (25点)，观察 Gurobi Log，亲眼看到 Gap 卡住不动，理解 Big-M 的危害。
        
2. **Level 2 (列生成基础 - Column Generation):**
    
    - 实现 **Set Partitioning** 主问题。
        
    - 子问题先用简单的 **DFS**（不考虑复杂剪枝）代替。
        
    - _目标：_ 跑通 CG 循环，看着目标函数值慢慢下降。
        
3. **Level 3 (标签算法 - The Engine):**
    
    - 手写 **Label Setting Algorithm**。
        
    - 实现 **Dominance Rule**（这是整个算法的灵魂）。
        
    - _目标：_ 能够快速解出 Pricing Subproblem。
        
4. **Level 4 (分支定价 - Branching):**
    
    - 实现 **Branching** 策略（如基于边的分支）。
        
    - _目标：_ 得到整数解，而不仅仅是 LP 松弛解。
        

**既然你是做运筹优化的，我们从 Level 1 开始动手写代码，还是直接跳到 Level 2 讲列生成的数学推导？**