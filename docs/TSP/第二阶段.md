这是《运筹学精确算法专题》的第二部分。

在第一阶段，我们发现 DFJ 模型的致命弱点是**约束数量爆炸** ($2^n$)。这一阶段，我们将引入现代求解器的核心机制——**Branch-and-Cut (分支切割法)**。

它的核心哲学是：**“沉默原则” (Silence is Golden)**。如果不等式没有被违反，我们就当它不存在；只有当求解器“犯错”时（比如走出了子回路），我们才动态添加约束进行修正。

---

# 运筹学精确算法专题二：割平面法与动态约束 (Branch-and-Cut)

**Topic 2: Branch-and-Cut - Dynamic Constraint Generation**

## 1. 核心思想：从“静态”到“动态”

在 MTZ 模型中，我们把所有约束一次性塞给求解器，这叫静态模型。

而在 Branch-and-Cut 中，我们只给求解器最基础的约束（度数约束），然后让求解器在一个“松弛”的空间里奔跑。

这个过程包含两个关键角色：

1. **Master Problem (主问题)**: 包含度数约束的松弛模型。
    
2. **Separation Oracle (分离预言机)**: 一个像“警察”一样的子程序。它不断检查主问题的解 $x^*$，一旦发现 $x^*$ 违背了某条没加进去的 DFJ 约束，就立刻生成这条约束并扔回主问题。
    

这个过程被称为**分离问题 (Separation Problem)**。

---

## 2. 算法流程详解 (The Algorithm Flow)

Branch-and-Cut 将 **Branch-and-Bound (分支定界)** 与 **Cutting Plane (割平面)** 结合在了一起。

### 流程步骤：

1. **初始化**：建立仅包含度数约束 ($\sum x = 2$) 的 LP 模型。
    
2. **求解节点**：求解当前节点的 LP 松弛解 $x^*$。
    
3. **分离 (Separation) - 关键步骤**：
    
    - **检查整数可行性**：如果 $x^*$ 是整数解（都是 0 或 1），检查它是否连通。
        
        - 如果不连通（即出现了子回路 $S$），**添加 DFJ 约束** $\sum_{i,j \in S} x_{ij} \le |S|-1$。这被称为 **Lazy Constraint**。
            
    - **检查 LP 紧致性 (进阶)**：如果 $x^*$ 是小数解（例如 $x_{1,2}=0.5$），我们也可以寻找是否有违反的约束。如果找到了，添加该约束（**User Cut**）来切割多面体，提高下界（Lower Bound）。
        
4. **重优化 (Re-optimize)**：加入新约束后，重新解 LP。
    
5. **分支 (Branching)**：如果无法找到违背的约束，且 $x^*$ 仍为小数，则进行传统的分支（比如令 $x_{1,2}=0$ 或 $x_{1,2}=1$）。
    

---

## 3. 核心难点：分离问题 (The Separation Problem)

如何快速找到那个被违背的集合 $S$？我们不能遍历所有子集。

这里分为两种情况：整数解分离 与 分数解分离。

### 3.1 整数解分离 (Integer Separation)

当 $x^*$ 已经是整数时，分离非常简单：

- **算法**：深度优先搜索 (DFS) 或 广度优先搜索 (BFS)。
    
- **逻辑**：遍历图，寻找连通分量 (Connected Components)。如果分量数量 $>1$，则每一个分量都是一个违背的集合 $S$。
    
- **复杂度**：$O(n)$。
    

### 3.2 分数解分离 (Fractional Separation)

这是 Concorde 等顶尖求解器的核心。当 $x^*$ 包含小数时（例如 $0.5, 0.8$），图是连通的，但可能违反了某些切割约束。

- **数学原理**：根据 **最大流最小割定理 (Max-Flow Min-Cut Theorem)**。
    
- **算法逻辑**：
    
    1. 我们将当前的解 $x^*_{ij}$ 看作图中边 $(i, j)$ 的**容量 (Capacity)**。
        
    2. 对于任意两点，计算它们之间的**最小割 (Global Min-Cut)**。
        
    3. 如果最小割的值 $< 2$（对于无向图），说明这个割集违反了 TSP 的连通性要求（正常割集应该 $\ge 2$）。
        
    4. 找到这个最小割对应的集合 $S$，添加约束 $\sum_{i \in S, j \notin S} x_{ij} \ge 2$。
        

---

## 4. 工业级代码实现 (Python + Gurobi)

我们将实现最常用的 **Lazy Constraint** 模式。这是目前工业界解决 TSP/VRP 的标准起手式。

### 4.1 代码结构

这段代码展示了如何使用 Gurobi 的 `Callback` 接口来实现动态约束添加。

Python

```
import gurobipy as gp
from gurobipy import GRB
import networkx as nx
import math

# --------------------------
# 1. 分离预言机 (Callback)
# --------------------------
def subtour_callback(model, where):
    # GRB.Callback.MIPSOL 表示求解器找到了一个新的整数解
    if where == GRB.Callback.MIPSOL:
        
        # 1. 获取当前整数解
        x_sol = model.cbGetSolution(model._vars)
        n = model._n
        
        # 2. 构建图 (仅包含被选中的边)
        G = nx.Graph()
        G.add_nodes_from(range(n))
        for (i, j) in x_sol.keys():
            if x_sol[i, j] > 0.5:
                G.add_edge(i, j)
        
        # 3. 寻找连通分量 (Separation)
        components = list(nx.connected_components(G))
        
        # 4. 如果连通分量 > 1，说明存在子回路 -> 添加约束
        if len(components) > 1:
            for component in components:
                # 策略：针对每个子回路 S，添加 DFJ 约束
                # sum(x_ij for i,j in S) <= |S| - 1
                
                # 这里的 quicksum 必须遍历 component 内部所有可能的边
                expr = gp.quicksum(model._vars[min(i,j), max(i,j)] 
                                   for i in component 
                                   for j in component 
                                   if i != j and (min(i,j), max(i,j)) in model._vars)
                
                # 添加 Lazy Constraint (这就相当于动态切了一刀)
                model.cbLazy(expr <= len(component) - 1)

# --------------------------
# 2. 主程序
# --------------------------
def solve_tsp_branch_and_cut(n, points):
    # 计算距离矩阵 (略，假设已有)
    dist = {(i,j): math.dist(points[i], points[j]) for i in range(n) for j in range(i+1, n)}

    m = gp.Model("TSP_BCP")
    
    # 变量：x[i,j] 为二进制变量
    x = m.addVars(dist.keys(), obj=dist, vtype=GRB.BINARY, name="x")
    
    # 基础约束：度数约束 (Degree Constraints)
    # 任何一个点 i，连接它的边数必须等于 2
    for i in range(n):
        m.addConstr(gp.quicksum(x[min(i,j), max(i,j)] 
                                for j in range(n) 
                                if i != j) == 2, name=f"Deg_{i}")

    # --- 关键配置 ---
    # 必须开启 LazyConstraints 参数，否则 callback 不会生效
    m.Params.LazyConstraints = 1
    
    # 将变量传递给 callback
    m._vars = x
    m._n = n
    
    # 开始求解，传入 callback
    m.optimize(subtour_callback)
    
    # 输出结果
    if m.status == GRB.OPTIMAL:
        print(f"Optimal TSP Tour Cost: {m.objVal}")
```

---

## 5. 深度辨析：Lazy Constraint vs User Cut

在 Gurobi/Cplex 等求解器中，你会看到两个术语。作为算法工程师，必须区分它们：

|**特性**|**Lazy Constraints (惰性约束)**|**User Cuts (用户割平面)**|
|---|---|---|
|**触发时机**|当发现一个**整数可行解**时 (MIPSOL)|当发现一个**分数松弛解**时 (MIPNODE)|
|**作用**|**剔除不可行解** (Feasibility)。如果没有它，得到的解可能是错的（有子回路）。|**加强下界** (Bound)。没有它解也是对的，但加上它能让 Gap 收敛得更快。|
|**必须性**|**必须** (对于 DFJ 模型)。因为初始模型是错的。|**可选**。用于加速。|
|**计算代价**|低 (只需跑 DFS/BFS)。|高 (可能需要跑 Max-Flow)。|

**工业建议**：

- **起步阶段**：只实现 Lazy Constraints（如上代码）。这对 $N < 100$ 的问题通常足够秒杀。
    
- **进阶阶段**：如果你发现 Root Node Gap 很大（比如 20%），且迟迟不下降，说明松弛太弱。这时需要实现 User Cuts，在分数解阶段就通过最大流算法把部分 Subtour 切掉。
    

---

## 6. 局限性与向下一阶段的演进

Branch-and-Cut 虽然强大，解决了 TSP 问题，但在面对 **VRPTW (带时间窗的车辆路径问题)** 时遇到了天花板。

**为什么 Branch-and-Cut 搞不定 VRPTW？**

1. **资源约束难以表达**：时间窗（Time Windows）和容量（Capacity）如果写成线性约束（类似 MTZ），LP 松弛会变得极差。
    
2. **切割困难**：对于 VRP，仅仅保证连通性是不够的，还需要保证路径不超时、不超重。这些“资源可行性”很难通过简单的线性割平面（Linear Cuts）来切除。
    

这就引出了我们下一阶段的主角——Branch-and-Price (分支定价)。

在下一阶段，我们将彻底改变视角：不再在“边”上纠缠，而是直接在“路径”上建模。

**下期预告：** 运筹学精确算法专题三：列生成与 Branch-and-Price —— 如何解决亿级变量的挑战。