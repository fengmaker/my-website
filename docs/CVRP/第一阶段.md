好的，我们正式进入 **CVRP (容量限制车辆路径问题)** 的第一阶段。

这一阶段被称为**“紧致模型与广义约束时代” (Compact Models & Generalized Constraints)**。

在这个阶段，学界的思维定势是：“VRP 不就是多辆车的 TSP 吗？那我们就在 TSP 模型的基础上改改不就行了？”

这种尝试虽然在今天看来很初级，但它定义了 CVRP 的数学骨架，是理解后续所有高级算法的基础。

---

# CVRP 第一阶段：双下标流模型与 GCC 约束

**Phase 1: Two-Index Flow Formulation & Generalized Capacity Constraints**

## 1. 场景定义与变量构建

假设有一个仓库（节点 0）和 $n$ 个客户（节点 $1 \dots n$）。

- $Q$：每辆车的最大载重。
    
- $d_i$：客户 $i$ 的需求量（货物重量）。
    
- $K$：车队规模（可用的车辆数）。
    

### 1.1 决策变量 (The Variable)

既然是模仿 TSP，我们依然使用**“边”**作为决策核心：

$$x_{ij} \in \{0, 1\}$$

- $x_{ij}=1$：表示有车辆从 $i$ 直接行驶到 $j$。
    
- $x_{ij}=0$：表示没有。
    

_(注：在 CVRP 中，通常使用无向图或对称图，即 $x_{ij}$ 代表 $i$ 和 $j$ 连通，为了简化，这里我们以无向边为例，即 $i < j$)_

### 1.2 目标函数

依然是最小化总行驶距离：

$$\min \sum_{i,j} c_{ij} x_{ij}$$

---

## 2. 模型的构建：从 TSP 到 CVRP 的质变

我们先写出容易的部分（度数约束），再看难的部分（容量约束）。

### 2.1 基础度数约束 (Degree Constraints)

这部分和 TSP 很像，但有一点关键不同——**仓库**。

1. 客户的度数：每个客户必须被访问一次。
    
    $$\sum_{j} x_{ij} = 2, \quad \forall i \in \{1, \dots, n\}$$
    
    (注：无向图中，进一次出一次意味着连接两条边，度数为 2)
    
2. 仓库的度数：如果有 $K$ 辆车出发并返回，那么仓库连接的边数必须是 $2K$。
    
    $$\sum_{j} x_{0j} = 2K$$
    

---

### 2.2 核心难点：广义容量约束 (GCC)

如果只写上面的度数约束，求解器会给你输出什么？

它会输出几个连通的大圈。但是，它根本不管这辆车装没装满！

一辆载重 10 吨的车，可能被分配了一条总需求 100 吨的路径。

为了限制容量，Laporte 等人（1980s）提出了著名的 **GCC (Generalized Capacity Constraints)**。

GCC 的逻辑推导：

随便圈出一群客户，构成集合 $S$（比如圈出了 5 个客户，总需求 $\sum d = 25$）。

- 车容量 $Q = 10$。
    
- **问**：要服务这 25 吨货物，至少需要几辆车进出这个圈子？
    
- **答**：$\lceil 25 / 10 \rceil = 3$ 辆车。
    
- **物理推论**：既然需要 3 辆车，每辆车要进一次、出一次（贡献 2 个度数）。那么，**跨越这个集合边界的边数，至少得是 $3 \times 2 = 6$ 条。**
    

数学公式：

对于任意客户子集 $S \subseteq V \setminus \{0\}, |S| \ge 2$:

$$\sum_{i \in S, j \notin S} x_{ij} \ge 2 \times r(S)$$

其中 $r(S)$ 是集合 $S$ 所需的最小车辆数下界：

$$r(S) = \left\lceil \frac{\sum_{i \in S} d_i}{Q} \right\rceil$$

---

## 3. 第一阶段的瓶颈：为什么这种模型解不动？

这个模型看起来很完美，逻辑无懈可击。但在实际跑代码时，一旦客户数 $N > 30 \sim 50$，Gurobi 就彻底卡死了。

为什么 TSP 用类似的约束能解几千个点，CVRP 却只能解几十个点？

根本原因在于 LP 松弛的“分数欺骗”。

### 3.1 瓶颈一：容量的“分数打包”漏洞 (Fractional Packing)

这是 CVRP 比 TSP 难的根本原因。请看下面这个致命的例子：

- **场景**：3 个客户 A, B, C。每个需求 $d=1$。车容量 $Q=2$。
    
- **物理事实**：一辆车装不下 3 个客户。必须派 2 辆车。
    
    - 真实边数需求：至少 4 条边连接仓库（2 车进出）。
        
- LP 松弛的“作弊”解：
    
    求解器把 $x_{ij}$ 设为 0.5。
    
    它构建了一个环：Warehouse - A - B - C - Warehouse。
    
    但所有边都是 $0.5$。
    
    - **检查度数**：每个点连接两条 0.5 的边，度数=1（如果归一化）或者符合 LP 约束。
        
    - **检查 GCC**：
        
        - 集合 $S=\{A,B,C\}$，总需求 3，容量 2，$r(S) = \lceil 1.5 \rceil = 2$。
            
        - GCC 要求：边界切断的边之和 $\ge 2 \times 2 = 4$。
            
        - **作弊解的边界**：Warehouse 连接 A (0.5) 和 C (0.5)。总和 = 1.0。
            
        - **确实违规了**。
            

但是！ 问题在于，为了修复这个违规，我们需要添加 GCC 切平面。然而，Bin Packing（装箱）问题本身就是极难的。

在一个复杂的图里，求解器很难通过调整 $x_{ij}$ 的小数指，去精确地“凑”出整数倍的车辆数。LP 松弛会倾向于用 $x=0.6, x=0.4$ 这种值去“偷”容量，导致下界（Lower Bound）非常松。

### 3.2 瓶颈二：GCC 的分离难题 (Separation Difficulty)

在 TSP 中，我们找子回路（Min-Cut）是多项式时间的（最大流算法）。

在 CVRP 中，我们要找一个违反 GCC 的集合 $S$。

即：找到一个集合 $S$，使得 $\text{Cut}(S) < 2 \times r(S)$。

注意看右边：$r(S) = \lceil \sum d_i / Q \rceil$。

右边这个函数不是线性的，甚至不是平滑的！ 它带有取整符号。

这导致分离 GCC 约束本身就是一个 NP-Hard 问题。

我们无法像 TSP 那样简单地跑一遍最大流就找到最紧的约束。我们需要用启发式的方法（比如 Shrinking Heuristics）去“猜”哪个集合违反了约束。

---

## 4. 第一阶段总结

|**维度**|**第一阶段 CVRP 模型**|
|---|---|
|**核心变量**|$x_{ij}$ (Edge-based)|
|**核心约束**|**GCC** (广义容量约束)：$\text{Cut}(S) \ge 2 \lceil \sum d / Q \rceil$|
|**优点**|模型直观，数学形式优美，是 TSP 模型的自然延伸。|
|**致命伤**|**LP 松弛太弱**。线性规划无法理解“取整”和“装箱”，导致下界极差。|
|**极限规模**|$N \approx 50$。超过这个数，Gap 很大，Branch-and-Bound 树也搜不完。|

教学启示：

这告诉我们，简单的类比（从 TSP 到 CVRP）是行不通的。CVRP 不仅仅是路由问题，它本质上是 “路由 (Routing) + 装箱 (Packing)” 的混合体。

第一阶段的模型只解决了路由，没解决装箱。

所以，历史迫使我们进入第二阶段：**如何加强割平面，专门去切掉那些“装箱装不下”的分数解？** 这就是 Lysgaard 及其 FCC 割平面的故事。

理解了第一阶段的失败，我们才能看懂后面算法的精妙。可以进入第二阶段了吗？