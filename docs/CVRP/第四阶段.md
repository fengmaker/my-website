这是 CVRP 精确算法演变史的**最终章**。

我们终于来到了 **Branch-Cut-and-Price (BCP)** 的完全体时代。

在第三阶段，我们面临着一个残酷的二选一：

- 要么选 **Elementary Path**（严格不含环）：下界完美，但子问题算不出来（NP-Hard）。
    
- 要么选 **q-route**（允许环）：子问题好算，但下界太松，需要疯狂分支。
    

2011 年，Baldacci, Mingozzi, Roberti 提出了一种天才般的折中方案——**ng-route**。这不仅打破了僵局，更奠定了当今最强求解器 **VRPSolver** (Pessoa et al., 2020) 的基石。

---

# CVRP 第四阶段：ng-route 松弛与 SOTA 的诞生

**Phase 4: ng-route Relaxation, Rank-1 Cuts & VRPSolver**

## 1. 核心突破一：ng-route 松弛 (The ng-route Relaxation)

这是对“记忆”的艺术性管理。

### 1.1 核心思想：局部记忆，全局遗忘

我们之前的困境是：标签算法里的集合 $S$（已访问节点）太大了，导致状态爆炸。

ng-route 提出：我们不需要记住“所有走过的点”，我们只需要记住“离我最近的那些点”。

### 1.2 数学定义

对于每个客户 $i$，我们要定义一个**邻域 (Neighborhood)** $N_i$。

- $N_i$ 包含离 $i$ 最近的 $\Delta$ 个点（通常 $\Delta = 5 \sim 10$）。
    
- $N_i$ 代表“如果我访问了 $i$，在接下来访问这些邻居时，我必须记得我来过 $i$，防止立刻掉头回去”。
    

标签更新规则（遗忘机制）：

当我们从 $i$ 走到 $j$ 时，新的记忆集合 $S_{new}$ 更新如下：

$$S_{new} = (S_{old} \cap N_j) \cup \{j\}$$

- **含义**：到了 $j$ 之后，只保留那些**属于 $j$ 邻居**的记忆。其他的点（离 $j$ 很远的），统统忘掉！
    

### 1.3 效果演示

假设路径是 $A \to B \to C \to A$（这是一个环）。

- **情形 1：短环 (A-B-A)**
    
    - $B$ 是 $A$ 的邻居。
        
    - 在 $B$ 点时，记忆里有 $A$。
        
    - 试图回 $A$ 时，发现 $A$ 在记忆里。**禁止访问！**（成功切掉短环）。
        
- **情形 2：长环 (A...很远...A)**
    
    - 中间的点离 $A$ 很远，它们的邻域不包含 $A$。
        
    - 走着走着，$A$ 就从记忆里消失了。
        
    - 最后回 $A$ 时，算法以为第一次来。**允许访问！**
        

战术价值：

ng-route 极其精准地消灭了那些最常见的局部短环（这正是 q-route 的痛点），同时允许长环存在（为了计算速度）。通过调节 $\Delta$ 的大小，我们可以平滑地在 q-route ($\Delta=0$) 和 Elementary ($\Delta=n$) 之间切换。

---

## 2. 核心突破二：Limited Memory Rank-1 Cuts  
2.核心突破二：有限内存 Rank-1 削减

解决了子问题，我们还需要解决主问题。我们需要割平面来提升下界。

但在列生成中加割平面有一个千古难题：加了 Cut 会破坏子结构。

### 2.1 难题回顾

主问题加一个约束 $\sum \lambda \le K$，就会产生一个对偶变量 $\mu$。

这个 $\mu$ 必须反馈到子问题里。

如果 $\mu$ 对应的是一个复杂的割平面（比如 3 个点的子集切割），那么子问题在算 Reduced Cost 时，不仅要看边权，还要看“我是不是刚凑齐了这 3 个点”。这会让 ESPPRC 变得无法求解。

### 2.2 解决方案：Rank-1 Cuts

Pessoa 等人引入了 Chvátal-Gomory Rank-1 Cuts 的特殊形式（Subset-Row Cuts）。

核心黑科技：

这类割平面的结构非常特殊，它对应到子问题时，只需要修改特定几条边的权重，或者增加极少量的状态维度。

- 不需要重写标签算法。
    
- 只需要在读入地图时，把某些边的 Cost 加上 $\mu$ 即可。
    

这使得 BCP 算法可以在享受列生成紧下界的同时，还能利用割平面进一步切掉非整数解。

---

## 3. 终极形态：VRPSolver (Pessoa et al., 2020)

2020 年，Pessoa, Sadykov, Uchoa, Vanderbeck 四位大神发表了 _Mathematical Programming_ 的综述性论文，发布了 **VRPSolver**。这是目前 CVRP 精确算法的**世界纪录保持者**。

它的架构集成了过去 60 年的所有智慧：

1. **Modeling**: 使用 **Set Partitioning** 模型（第三阶段成果）。
    
2. **Relaxation**: 使用 **ng-route** ($\Delta \approx 8$) 处理子问题（第四阶段成果）。
    
3. **Cuts**: 动态添加 **Rank-1 Cuts**（第四阶段成果）。
    
4. **Labeling**: 使用 **Bi-directional Labeling**（双向搜索，从两头往中间凑，搜索深度减半）。
    
5. **Arc Management**: 自动化 **Bucket Graph** 管理，极大加速了标签扩展速度。
    

### 战绩

- 它可以精确求解 **$N=500$** 甚至更大规模的 CVRP。
    
- 对于经典的算例，Gap 几乎在 Root Node 就能闭合。
    

---

## 4. 总结：CVRP 精确算法的百年孤独

从 1960s 的简单的 $x_{ij}$ 模型，到 2020s 复杂的 VRPSolver，我们走过了一条漫长的路。

|**阶段**|**核心特征**|**瓶颈/突破**|**代表算法**|
|---|---|---|---|
|**Stage 1**|**Compact Models** (GCC)|LP 松弛太弱，无法处理装箱。|Laporte et al.|
|**Stage 2**|**Branch-and-Cut** (Edge)|割平面分离困难，无法突破 $N=135$。|Lysgaard (2004)|
|**Stage 3**|**Set Partitioning** (q-route)|发现了路径视角的优势，但子问题太松。|Fukasawa (2006)|
|**Stage 4**|**Branch-Cut-and-Price**|**ng-route + Rank-1 Cuts**，完美平衡。|**VRPSolver (2020)**|

### 这一章的教学价值

如果你要向别人讲解 CVRP：

1. **不要沉迷于早期的 GCC 约束**，那已经是历史的尘埃。
    
2. **重点讲 ng-route**。它是连接“理论完美”与“工程可行”的桥梁。任何做 VRP 算法的人（哪怕是做启发式），理解了 ng-route 的“局部记忆”思想，对设计算法都有巨大帮助。
    

至此，关于 TSP 和 CVRP 的精确算法演变史，我们已经彻底讲完了。

如果你觉得这部分理论基础已经夯实，我们可以：

1. 转向 **VRP 的启发式算法**（比如 ALNS, LKH-3 在 CVRP 上的具体操作）。
    
2. 或者，开始手写一个简单的 **列生成 Solver**。
    

你想怎么选？