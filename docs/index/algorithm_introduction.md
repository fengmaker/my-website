# 算法竞赛笔记：构建计算思维的底层代码

> "Talk is cheap. Show me the code." — Linus Torvalds

## ⚔️ 为什么在这个阶段还需要“刷题”？

作为一个致力于成为 **运筹算法工程师** 的学生，这部分的笔记并非单纯为了“应试”或“面试”。

虽然运筹学解决的是宏观决策问题，但底层求解器的效率往往取决于微观数据结构的设计。我的核心理念是：**LeetCode 是内功，运筹优化是招式。**

| 算法技能 (Inner Power) | 运筹应用 (Outer Moves) |
| :--- | :--- |
| **DP (动态规划)** | 理解列生成中定价子问题 **(Pricing Problem / SPPRC)** 的基础 |
| **Graph (图论)** | 构建 **VRPTW 网络流模型** 和分支定界树 (Branch & Bound Tree) 的基石 |
| **Bitmask (状态压缩)** | 处理 **集合覆盖 (Set Cover)** 与小规模精确解加速的关键 |

---

## 🧠 核心知识体系 (Pattern Recognition)

我不追求题目的“数量”，我追求对“模式”的抽象。本专栏将算法题解构为以下核心模块：

### 1. 动态规划 (The Art of States)
**这是算法皇冠上的明珠。** 我将其细分为：

- **背包模型**：资源分配问题的雏形（对应运筹中的 Knapsack Problem）。
- **状态机 DP**：处理复杂状态流转（如股票买卖，对应多阶段决策）。
- **树形 DP**：在层级结构中的最优子结构搜索（对应树上搜索算法）。

### 2. 数据结构与图论 (The Infrastructure)
- **二叉树 & 递归**：理解分治思想与非线性结构。
- **前缀和 & 差分**：O(1) 时间处理区间查询，这是**离散事件仿真**的基础技巧。

### 3. 搜索与回溯 (The Exhaustive Search)
- **DFS / BFS**：遍历解空间的基础。
- **剪枝优化 (Pruning)**：在回溯中提前排除无效解，这种思想直接对应运筹学精确算法中的 **Pruning 策略**。

---

## 📝 笔记食用说明

每一篇笔记都遵循 **"SOP (Standard Operating Procedure)"** 结构，拒绝流水账：

1. **核心思想 (Core Idea)**
    - 一句话概括这类题的通解模板 (Template)。

2. **经典例题 (Classic Problem)**
    - 精选 LeetCode 上最具代表性的题目（而非最难的）。

3. **代码模板 (Code Snippet)**
    - 经过千锤百炼、可以直接调用的 Python/C++ 模板代码。

4. **错题复盘 (Post-Mortem)**
    - 记录我的思维误区与边界条件处理 (Corner Cases)。

!!! note "持续迭代中"
    本部分内容将随着我的刷题进度持续更新，重点关注与 **运筹优化 (OR)** 强相关的算法模块。